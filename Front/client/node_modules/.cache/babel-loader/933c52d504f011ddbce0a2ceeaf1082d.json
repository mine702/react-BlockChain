{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:wrap:bool\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst boolCasesBasic = [boolFromString, boolFromBoxedPrimitive, boolFromCodecBoolValue, boolFromCodecBoolError, boolFromCodecUdvtValue, boolFromCodecUdvtError, boolFromOther //must go last!\n];\nexports.boolCases = [boolFromTypeValueInput, ...boolCasesBasic];\n\nfunction* boolFromString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  } //strings are true unless they're falsy or the case-insensitive string \"false\"\n\n\n  const asBoolean = Boolean(input) && input.toLowerCase() !== \"false\";\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}\n\nfunction* boolFromBoxedPrimitive(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedPrimitive(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed primitive\");\n  } //unbox and try again\n\n\n  return yield* dispatch_1.wrapWithCases(dataType, input.valueOf(), wrapOptions, exports.boolCases);\n}\n\nfunction* boolFromCodecBoolValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to BoolError case\n    Messages.errorResultMessage);\n  }\n\n  const asBoolean = input.value.asBoolean;\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}\n\nfunction* boolFromCodecBoolError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a value rather than an error\");\n  } //these two error types will be regarded as true\n\n\n  const allowedErrors = [\"BoolOutOfRangeError\", \"BoolPaddingError\"];\n\n  if (!allowedErrors.includes(input.error.kind)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean: true\n    }\n  };\n}\n\nfunction* boolFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"bool\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, disallowing type/value input\n\n\n  return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), boolCasesBasic);\n}\n\nfunction* boolFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* boolFromCodecBoolValue(dataType, input.value, wrapOptions);\n}\n\nfunction* boolFromCodecUdvtError(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"error\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a value rather than an error\");\n  } //wrapped errors will have to be unwrapped, others can be rejected\n\n\n  if (input.error.kind !== \"WrappedError\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* boolFromCodecBoolError(dataType, input.error.error, wrapOptions);\n}\n\nfunction* boolFromOther(dataType, input, wrapOptions) {\n  //fallback case: just go by truthiness/falsiness\n  //(this case has to be last because there are various other\n  //cases we do not want to go by truthiness/falsiness!)\n  if (Utils.isWrappedResult(input)) {\n    //...except for these, which may error\n    //(note that we do this even when loose is on!)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n\n  if (Utils.isTypeValueInput(input)) {\n    //...and these, which also may error\n    //(note that we do this even when loose is on!)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n  }\n\n  const asBoolean = Boolean(input);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asBoolean\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["debug","debug_1","boolCasesBasic","boolFromString","boolFromBoxedPrimitive","boolFromCodecBoolValue","boolFromCodecBoolError","boolFromCodecUdvtValue","boolFromCodecUdvtError","boolFromOther","exports","boolFromTypeValueInput","dataType","input","wrapOptions","errors_1","name","asBoolean","Boolean","toLowerCase","type","kind","value","Utils","isBoxedPrimitive","dispatch_1","valueOf","isWrappedResult","typeClass","Messages","wrappedTypeMessage","errorResultMessage","allowedErrors","includes","error","isTypeValueInput","specifiedTypeMessage","Object","loose"],"sourceRoot":"","sources":["../../../lib/wrap/bool.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiSelector = exports.abiTupleSignature = exports.abiSignature = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:utils\");\n\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\n\nconst Evm = __importStar(require(\"../evm\"));\n\nconst Ast = __importStar(require(\"../ast\"));\n\nexports.DEFAULT_CONSTRUCTOR_ABI = {\n  type: \"constructor\",\n  inputs: [],\n  stateMutability: \"nonpayable\"\n}; //note the return value only includes functions!\n\nfunction computeSelectors(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return Object.assign({}, ...abi.filter(abiEntry => abiEntry.type === \"function\").map(abiEntry => ({\n    [abiSelector(abiEntry)]: abiEntry\n  })));\n}\n\nexports.computeSelectors = computeSelectors; //does this ABI have a payable fallback (or receive) function?\n\nfunction abiHasPayableFallback(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return abi.some(abiEntry => (abiEntry.type === \"fallback\" || abiEntry.type === \"receive\") && abiEntry.stateMutability === \"payable\");\n}\n\nexports.abiHasPayableFallback = abiHasPayableFallback; //NOTE: this function returns the written out SIGNATURE, not the SELECTOR\n\nfunction abiSignature(abiEntry) {\n  return abiEntry.name + abiTupleSignature(abiEntry.inputs);\n}\n\nexports.abiSignature = abiSignature;\n\nfunction abiTupleSignature(parameters) {\n  let components = parameters.map(abiTypeSignature);\n  return \"(\" + components.join(\",\") + \")\";\n}\n\nexports.abiTupleSignature = abiTupleSignature;\n\nfunction abiTypeSignature(parameter) {\n  let tupleMatch = parameter.type.match(/tuple(.*)/);\n\n  if (tupleMatch === null) {\n    //does not start with \"tuple\"\n    return parameter.type;\n  } else {\n    let tail = tupleMatch[1]; //everything after \"tuple\"\n\n    let tupleSignature = abiTupleSignature(parameter.components);\n    return tupleSignature + tail;\n  }\n}\n\nfunction abiSelector(abiEntry) {\n  let signature = abiSignature(abiEntry); //NOTE: web3's soliditySha3 has a problem if the empty\n  //string is passed in.  Fortunately, that should never happen here.\n\n  let hash = web3_utils_1.default.soliditySha3({\n    type: \"string\",\n    value: signature\n  });\n\n  switch (abiEntry.type) {\n    case \"event\":\n      return hash;\n\n    case \"function\":\n    case \"error\":\n      return hash.slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE);\n    //arithmetic to account for hex string\n  }\n}\n\nexports.abiSelector = abiSelector; //note: undefined does not match itself :P\n\nfunction abisMatch(entry1, entry2) {\n  //we'll consider two abi entries to match if they have the same\n  //type, name (if applicable), and inputs (if applicable).\n  //since there's already a signature function, we can just use that.\n  if (!entry1 || !entry2) {\n    return false;\n  }\n\n  if (entry1.type !== entry2.type) {\n    return false;\n  }\n\n  switch (entry1.type) {\n    case \"function\":\n    case \"event\":\n    case \"error\":\n      return abiSignature(entry1) === abiSignature(entry2);\n\n    case \"constructor\":\n      return abiTupleSignature(entry1.inputs) === abiTupleSignature(entry2.inputs);\n\n    case \"fallback\":\n    case \"receive\":\n      return true;\n  }\n}\n\nexports.abisMatch = abisMatch;\n\nfunction definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {\n  try {\n    return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));\n  } catch (_) {\n    return false; //if an exception occurs, well, that's not a match!\n  }\n}\n\nexports.definitionMatchesAbi = definitionMatchesAbi;\n\nfunction topicsCount(abiEntry) {\n  let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector\n\n  return abiEntry.inputs.filter(_ref => {\n    let {\n      indexed\n    } = _ref;\n    return indexed;\n  }).length + selectorCount;\n}\n\nexports.topicsCount = topicsCount;\n\nfunction abiEntryIsObviouslyIllTyped(abiEntry) {\n  switch (abiEntry.type) {\n    case \"fallback\":\n    case \"receive\":\n      return false;\n\n    case \"constructor\":\n    case \"event\":\n    case \"error\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);\n\n    case \"function\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) || abiEntry.outputs.some(abiParameterIsObviouslyIllTyped);\n  }\n}\n\nexports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;\n\nfunction abiParameterIsObviouslyIllTyped(abiParameter) {\n  const legalBaseTypeClasses = [\"uint\", \"int\", \"fixed\", \"ufixed\", \"bool\", \"address\", \"bytes\", \"string\", \"function\", \"tuple\"];\n  const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];\n  const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);\n\n  if (abiParameter.components) {\n    return abiParameter.components.some(abiParameterIsObviouslyIllTyped) || baseTypeClassIsObviouslyWrong;\n  } else {\n    return baseTypeClassIsObviouslyWrong;\n  }\n}\n\nfunction abiEntryHasStorageParameters(abiEntry) {\n  const isStorage = parameter => parameter.type.endsWith(\" storage\");\n\n  return abiEntry.type === \"function\" && (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)); //Note the lack of recursion!  Storage parameters can only occur at\n  //top level so there's no need to recurse here\n  //(they can also only occur for functions)\n}\n\nexports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;","map":{"version":3,"mappings":"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","names":["debug","debug_1","exports","type","inputs","stateMutability","computeSelectors","abi","undefined","Object","assign","filter","abiEntry","map","abiSelector","abiHasPayableFallback","some","abiSignature","name","abiTupleSignature","parameters","components","abiTypeSignature","join","parameter","tupleMatch","match","tail","tupleSignature","signature","hash","web3_utils_1","soliditySha3","value","slice","Evm","Utils","SELECTOR_SIZE","abisMatch","entry1","entry2","definitionMatchesAbi","definition","referenceDeclarations","Ast","definitionToAbi","_","topicsCount","selectorCount","anonymous","indexed","length","abiEntryIsObviouslyIllTyped","abiParameterIsObviouslyIllTyped","outputs","abiParameter","legalBaseTypeClasses","baseTypeClass","baseTypeClassIsObviouslyWrong","includes","abiEntryHasStorageParameters","isStorage","endsWith"],"sourceRoot":"","sources":["../../../lib/abi-data/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
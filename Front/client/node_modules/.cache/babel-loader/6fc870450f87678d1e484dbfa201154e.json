{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrap = exports.udvtCases = exports.txOptionsCases = exports.tupleCases = exports.arrayCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:wrap:wrap\");\n\nconst Format = __importStar(require(\"../format\"));\n\nconst errors_1 = require(\"./errors\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst integer_1 = require(\"./integer\");\n\nconst decimal_1 = require(\"./decimal\");\n\nconst bool_1 = require(\"./bool\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst address_1 = require(\"./address\");\n\nconst string_1 = require(\"./string\");\n\nconst function_1 = require(\"./function\"); //this file contains the main wrap function, as well as the cases\n//for arrays, tuples, udvts, and tx options.  all other types get their\n//own file.\n\n\nconst arrayCasesBasic = [arrayFromArray, arrayFromCodecArrayValue, arrayFailureCase];\nexports.arrayCases = [arrayFromTypeValueInput, ...arrayCasesBasic];\nconst tupleCasesBasic = [tupleFromArray, tupleFromCodecTupleLikeValue, tupleFromObject, tupleFailureCase];\nexports.tupleCases = [tupleFromTypeValueInput, ...tupleCasesBasic];\nconst txOptionsCasesBasic = [optionsFromCodecOptionsValue, optionsFromObject, optionsFailureCase];\nexports.txOptionsCases = [optionsFromTypeValueInput, ...txOptionsCasesBasic];\nexports.udvtCases = [//no separate case for udvtFromUdvtValue,\n//since underlying already handles this\nudvtFromUnderlying];\n\nfunction* wrap(dataType, input, wrapOptions) {\n  if (!wrapOptions.name) {\n    wrapOptions = Object.assign(Object.assign({}, wrapOptions), {\n      name: \"<input>\"\n    });\n  }\n\n  switch (dataType.typeClass) {\n    case \"uint\":\n    case \"int\":\n    case \"enum\":\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, integer_1.integerCases);\n\n    case \"fixed\":\n    case \"ufixed\":\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, decimal_1.decimalCases);\n\n    case \"bool\":\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, bool_1.boolCases);\n\n    case \"bytes\":\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, bytes_1.bytesCases);\n\n    case \"address\":\n    case \"contract\":\n      //these are treated the same\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, address_1.addressCases);\n\n    case \"string\":\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, string_1.stringCases);\n\n    case \"function\":\n      //special check: weed out internal functions\n      if (dataType.visibility === \"internal\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity\n        `Wrapping/encoding for internal function pointers is not supported`);\n      } //otherwise, go ahead\n\n\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, function_1.functionExternalCases);\n\n    case \"array\":\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, exports.arrayCases);\n\n    case \"struct\":\n    case \"tuple\":\n      //these are treated the same as well\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, exports.tupleCases);\n\n    case \"userDefinedValueType\":\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, exports.udvtCases);\n\n    case \"options\":\n      return yield* dispatch_1.wrapWithCases(dataType, input, wrapOptions, exports.txOptionsCases);\n\n    default:\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity\n      `Wrapping/encoding for type ${Format.Types.typeStringWithoutLocation(dataType)} is not supported`);\n  }\n}\n\nexports.wrap = wrap; //array cases\n\nfunction* arrayFromArray(dataType, input, wrapOptions) {\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n\n  if (dataType.kind === \"static\" && !dataType.length.eqn(input.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(dataType.length, input.length));\n  } //can't do yield in a map, so manual loop here\n\n\n  let value = [];\n\n  for (let index = 0; index < input.length; index++) {\n    value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), {\n      name: `${wrapOptions.name}[${index}]`,\n      specificityFloor: 5 //errors in components are quite specific!\n\n    })));\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* arrayFromCodecArrayValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  } //we won't bother with detailed typechecking as much of it is handled\n  //either in the call to arrayFromArray or in the wrapping of the\n  //individual elements; we will check dynamic vs static though as that\n  //isn't handled elsewhere\n\n\n  if (!wrapOptions.loose && input.type.kind === dataType.kind) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  } //note that we do *not* just copy over input.value, but rather we\n  //defer to arrayFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n\n\n  const value = input.value;\n  return yield* arrayFromArray(dataType, value, wrapOptions);\n}\n\nfunction* arrayFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //don't turn on loose here, only do that for non-container types!\n\n\n  return yield* dispatch_1.wrapWithCases(dataType, input.value, wrapOptions, arrayCasesBasic);\n}\n\nfunction* arrayFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, type/value pair or wrapped array\");\n} //tuple/struct cases;\n//note even with loose turned off, we won't distinguish\n//between tuples and structs\n\n\nfunction* tupleFromArray(dataType, input, wrapOptions) {\n  //first: obtain the types of the members\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n\n  debug(\"input is array\");\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n\n  if (memberTypes.length !== input.length) {\n    debug(\"input is wrong-length array\");\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(memberTypes.length, input.length));\n  } //can't do yield in a map, so manual loop here\n\n\n  let value = [];\n\n  for (let index = 0; index < input.length; index++) {\n    const memberName = memberTypes[index].name;\n    debug(\"wrapping %s\", memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), {\n        name: memberName ? wrapOptions.name.match(/^<.*>$/) //hack?\n        ? memberName : `${wrapOptions.name}.${memberName}` : `${wrapOptions.name}[${index}]`,\n        specificityFloor: 5\n      }))\n    });\n  } //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* tupleFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n\n  if (!wrapOptions.loose && Utils.isTypeValueInput(input)) {\n    //let's exclude these unless loose is turned on\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n  }\n\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n\n  if (memberTypes.some(_ref => {\n    let {\n      name\n    } = _ref;\n    return !name;\n  })) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, \"Plain object input is allowed only when all elements of tuple are named\");\n  }\n\n  let unusedKeys = new Set(Object.keys(input));\n  let value = [];\n\n  for (let index = 0; index < memberTypes.length; index++) {\n    //note we had better process these in order!\n    const memberName = memberTypes[index].name;\n\n    if (!(memberName in input)) {\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Missing key from tuple or struct: ${memberName}`);\n    }\n\n    unusedKeys.delete(memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${memberName}`,\n        specificityFloor: 4 //not sure this warrants a 5\n\n      }))\n    });\n  }\n\n  if (!wrapOptions.loose) {\n    if (unusedKeys.size > 0) {\n      //choose one arbitrarily\n      const exampleKey = unusedKeys.values().next().value;\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Unknown key ${exampleKey} included`);\n    }\n  } //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* tupleFromCodecTupleLikeValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"tuple\" && input.type.typeClass !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  } //not going to do much typechecking here as it'll be handled in the call\n  //to tupleFromArray\n  //Typescript complains if I try to say it can be either struct or\n  //tuple, so, uh, let's just tell it it's a tuple <shrug>\n\n\n  const coercedInput = input; //HACK!\n  //note that we do *not* just copy over input.value, but rather we\n  //defer to tupleFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n\n  return yield* tupleFromArray(dataType, coercedInput.value.map(_ref2 => {\n    let {\n      value\n    } = _ref2;\n    return value;\n  }), wrapOptions);\n}\n\nfunction* tupleFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"tuple\" && input.type !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //don't turn on loose here, only do that for non-container types!\n\n\n  return yield* dispatch_1.wrapWithCases(dataType, input.value, wrapOptions, tupleCasesBasic);\n}\n\nfunction* tupleFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, plain object, type/value pair or wrapped tuple or struct\");\n}\n\nfunction memberTypesForType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    case \"tuple\":\n      return dataType.memberTypes;\n      break;\n\n    case \"struct\":\n      debug(\"wrapping for struct %s\", dataType.typeName);\n      return Format.Types.fullType(dataType, userDefinedTypes).memberTypes;\n  }\n} //udvt cases\n\n\nfunction* udvtFromUnderlying(dataType, input, wrapOptions) {\n  const {\n    underlyingType\n  } = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n  const value = yield* wrap(underlyingType, input, wrapOptions);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: value\n  };\n} //tx options cases\n\n\nfunction* optionsFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n\n  debug(\"options input is object: %O\", input);\n  debug(\"wrapOptions: %O\", wrapOptions);\n\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  } //now... the main case\n\n\n  let value = {};\n  const uintKeys = [\"gas\", \"gasPrice\", \"value\", \"nonce\", \"maxFeePerGas\", \"maxPriorityFeePerGas\"];\n  const uint8Keys = [\"type\"];\n  const addressKeys = [\"from\", \"to\"];\n  const bytesKeys = [\"data\"];\n  const boolKeys = [\"overwrite\"];\n  const accessListKeys = [\"accessList\"];\n  const specialKeys = [\"privateFor\"];\n  const allKeys = [...uintKeys, ...uint8Keys, ...addressKeys, ...bytesKeys, ...boolKeys, ...accessListKeys, ...specialKeys];\n  const badKey = Object.keys(input).find(key => !allKeys.includes(key));\n  const goodKey = Object.keys(input).find(key => allKeys.includes(key));\n\n  if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {\n    //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK\n    //to preserve existing behavior of Truffle Contract (perhaps we can\n    //change this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included unknown option ${badKey}`);\n  }\n\n  if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {\n    //similarly, if oldOptionsBehavior is on, we require at least\n    //one *legit* key (again, HACK to preserve existing behavior,\n    //maybe remove this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included no recognized options`);\n  } //otherwise, if all keys are transaction options, let's process them...\n  //part 1: uint options\n\n\n  for (const key of uintKeys) {\n    //note we check input[key] !== undefined, rather than key in input,\n    //because if one of them is undefined we want to just allow that but ignore it\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* dispatch_1.wrapWithCases({\n        typeClass: \"uint\",\n        bits: 256\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      value[key] = wrappedOption.value.asBN;\n    }\n  } //part 2: uint8 options (just type for now)\n\n\n  for (const key of uint8Keys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* dispatch_1.wrapWithCases({\n        typeClass: \"uint\",\n        bits: 8\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      const asBN = wrappedOption.value.asBN; //since this is just type right now, we're going to reject illegal types\n\n      if (asBN.gten(0xc0)) {\n        //not making a constant for this, this is its only use here\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.type`, 4, \"Transaction types must be less than 0xc0\");\n      } //for compatibility, we give type as a hex string rather than\n      //leaving it as a BN.  Since it's unsigned we don't have to\n      //worry about negatives.\n\n\n      value[key] = Conversion.toHexString(asBN);\n    }\n  } //part 3: address options\n\n\n  for (const key of addressKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* dispatch_1.wrapWithCases({\n        typeClass: \"address\",\n        kind: \"general\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), address_1.addressCases);\n      value[key] = wrappedOption.value.asAddress;\n    }\n  } //part 4: bytestring options\n\n\n  for (const key of bytesKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* dispatch_1.wrapWithCases({\n        typeClass: \"bytes\",\n        kind: \"dynamic\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bytes_1.bytesCases);\n      value[key] = wrappedOption.value.asHex;\n    }\n  } //part 5: boolean options\n\n\n  for (const key of boolKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* dispatch_1.wrapWithCases({\n        typeClass: \"bool\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bool_1.boolCases);\n      value[key] = wrappedOption.value.asBoolean;\n    }\n  } //part 6: the access list\n\n\n  for (const key of accessListKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* dispatch_1.wrapWithCases({\n        typeClass: \"array\",\n        kind: \"dynamic\",\n        baseType: {\n          typeClass: \"tuple\",\n          memberTypes: [{\n            name: \"address\",\n            type: {\n              typeClass: \"address\",\n              kind: \"general\"\n            }\n          }, {\n            name: \"storageKeys\",\n            type: {\n              typeClass: \"array\",\n              kind: \"dynamic\",\n              baseType: {\n                //we use uint256 rather than bytes32 to allow\n                //abbreviating and left-padding\n                typeClass: \"uint\",\n                bits: 256\n              }\n            }\n          }]\n        }\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), exports.arrayCases);\n      value[key] = Format.Utils.Inspect.nativizeAccessList(wrappedOption);\n    }\n  } //part 7: the special case of privateFor\n\n\n  if (input.privateFor !== undefined) {\n    //this doesn't correspond to any of our usual types, so we have to handle it specially\n    if (!Array.isArray(input.privateFor)) {\n      throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, \"Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes\");\n    }\n\n    value.privateFor = input.privateFor.map((publicKey, index) => {\n      if (Utils.isBoxedString(publicKey)) {\n        publicKey = publicKey.valueOf();\n      }\n\n      if (typeof publicKey !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not a string`);\n      }\n\n      if (!Utils.isBase64(publicKey)) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not base64-encoded`);\n      }\n\n      const length = Utils.base64Length(publicKey);\n\n      if (length !== 32) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);\n      }\n\n      return publicKey;\n    });\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* optionsFromCodecOptionsValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  const value = input.value; //unlike in the array or tuple cases, here should not have\n  //to worry about compatible-but-not-identical types, so it's\n  //safe to just copy value over\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* optionsFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //because options, unlike other containers, has specific types, we *will* turn on loose\n\n\n  return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), txOptionsCasesBasic);\n}\n\nfunction* optionsFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Transaction options input was not a plain object, type/value pair or wrapped options object\");\n}","map":{"version":3,"mappings":"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","names":["debug","debug_1","arrayCasesBasic","arrayFromArray","arrayFromCodecArrayValue","arrayFailureCase","exports","arrayFromTypeValueInput","tupleCasesBasic","tupleFromArray","tupleFromCodecTupleLikeValue","tupleFromObject","tupleFailureCase","tupleFromTypeValueInput","txOptionsCasesBasic","optionsFromCodecOptionsValue","optionsFromObject","optionsFailureCase","optionsFromTypeValueInput","udvtFromUnderlying","wrap","dataType","input","wrapOptions","name","typeClass","dispatch_1","integer_1","decimal_1","bool_1","bytes_1","address_1","string_1","visibility","errors_1","function_1","Format","Types","typeStringWithoutLocation","Array","isArray","kind","length","eqn","Messages","wrongArrayLengthMessage","value","index","push","baseType","Object","specificityFloor","type","Utils","isWrappedResult","wrappedTypeMessage","errorResultMessage","loose","isTypeValueInput","specifiedTypeMessage","memberTypes","memberTypesForType","userDefinedTypes","memberName","match","isPlainObject","some","unusedKeys","Set","keys","delete","size","exampleKey","values","next","coercedInput","map","typeName","fullType","underlyingType","uintKeys","uint8Keys","addressKeys","bytesKeys","boolKeys","accessListKeys","specialKeys","allKeys","badKey","find","key","includes","goodKey","undefined","oldOptionsBehavior","wrappedOption","bits","asBN","gten","Conversion","toHexString","asAddress","asHex","asBoolean","Inspect","nativizeAccessList","privateFor","publicKey","isBoxedString","valueOf","isBase64","base64Length"],"sourceRoot":"","sources":["../../../lib/wrap/wrap.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
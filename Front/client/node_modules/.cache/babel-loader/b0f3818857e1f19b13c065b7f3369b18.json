{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAndWrap = exports.wrapForMethod = exports.wrapMultiple = exports.Messages = exports.wrap = exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:wrap\");\n\nconst priority_1 = require(\"./priority\");\n\nconst errors_1 = require(\"./errors\");\n\nObject.defineProperty(exports, \"NoOverloadsMatchedError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoOverloadsMatchedError;\n  }\n});\nObject.defineProperty(exports, \"NoUniqueBestOverloadError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoUniqueBestOverloadError;\n  }\n});\nObject.defineProperty(exports, \"TypeMismatchError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.TypeMismatchError;\n  }\n});\nObject.defineProperty(exports, \"BadResponseTypeError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.BadResponseTypeError;\n  }\n});\n\n__exportStar(require(\"./errors\"), exports);\n\nconst wrap_1 = require(\"./wrap\");\n\nObject.defineProperty(exports, \"wrap\", {\n  enumerable: true,\n  get: function () {\n    return wrap_1.wrap;\n  }\n});\n\n__exportStar(require(\"./types\"), exports);\n\nexports.Messages = __importStar(require(\"./messages\"));\n\nfunction* wrapMultiple(types, inputs, wrapOptions) {\n  //just wrap the types in a tuple and defer to wrap()\n  const combinedType = {\n    typeClass: \"tuple\",\n    memberTypes: types\n  };\n  debug(\"wrapping multiple\");\n  const wrappedTogether = yield* wrap_1.wrap(combinedType, inputs, wrapOptions);\n  return wrappedTogether.value.map(_ref => {\n    let {\n      value\n    } = _ref;\n    return value;\n  });\n}\n\nexports.wrapMultiple = wrapMultiple; //note: turns on loose\n\nfunction* wrapForMethod(method, inputs, resolveOptions) {\n  const wrapped = yield* wrapForMethodRaw(method, inputs, resolveOptions, true);\n  return wrappingToResolution(method, wrapped);\n}\n\nexports.wrapForMethod = wrapForMethod;\n\nfunction wrappingToResolution(method, wrapped) {\n  if (wrapped.length > 0 && wrapped[wrapped.length - 1].type.typeClass === \"options\") {\n    //there's options\n    const wrappedArguments = wrapped.slice(0, -1); //cut off options\n\n    const options = wrapped[wrapped.length - 1].value;\n    return {\n      method,\n      arguments: wrappedArguments,\n      options\n    };\n  } else {\n    //no options\n    return {\n      method,\n      arguments: wrapped,\n      options: {}\n    };\n  }\n} //doesn't separate out options from arguments & doesn't turn on loose\n\n\nfunction* wrapForMethodRaw(method, inputs, _ref2) {\n  let {\n    userDefinedTypes,\n    allowOptions\n  } = _ref2;\n  let loose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  debug(\"wrapping for method\");\n\n  if (method.inputs.length === inputs.length) {\n    //no options case\n    debug(\"no options\");\n    return yield* wrapMultiple(method.inputs, inputs, {\n      userDefinedTypes,\n      oldOptionsBehavior: true,\n      loose,\n      name: \"<arguments>\"\n    });\n  } else if (allowOptions && method.inputs.length === inputs.length - 1) {\n    //options case\n    debug(\"options\");\n    const inputsWithOptions = [...method.inputs, {\n      name: \"<options>\",\n      type: {\n        typeClass: \"options\"\n      }\n    }];\n    return yield* wrapMultiple(inputsWithOptions, inputs, {\n      userDefinedTypes,\n      oldOptionsBehavior: true,\n      loose,\n      name: \"<arguments>\"\n    });\n  } else {\n    //invalid length case\n    const orOneMore = allowOptions ? ` (or ${method.inputs.length + 1} counting transaction options)` : \"\";\n    throw new errors_1.TypeMismatchError({\n      typeClass: \"tuple\",\n      memberTypes: method.inputs\n    }, inputs, \"<arguments>\", 5, `Incorrect number of arguments (expected ${method.inputs.length}${orOneMore}, got ${inputs.length})`);\n  }\n}\n\nfunction* resolveAndWrap(methods, inputs, _ref3) {\n  let {\n    userDefinedTypes,\n    allowOptions\n  } = _ref3;\n\n  //despite us having a good system for overload resolution, we want to\n  //use it as little as possible!  That's because using it means we don't\n  //get great error messages.  As such, we're going to do a bunch to filter\n  //things beforehand, so that we get good error messages.\n  if (methods.length === 1) {\n    //if there's only one possibility, we just defer to wrapForMethod\n    //if we ignore error messages this is silly... but we're not!\n    //this is important for good error messages in this case\n    return yield* wrapForMethod(methods[0], inputs, {\n      userDefinedTypes,\n      allowOptions\n    });\n  } //OK, so, there are multiple possibilities then.  let's try to filter things down by length.\n\n\n  const possibleMatches = methods.filter(method => method.inputs.length === inputs.length); //but, we've also got to account for the possibility of options\n\n  let possibleMatchesWithOptions = [];\n  let possibleOptions = {};\n\n  if (allowOptions && inputs.length > 0) {\n    //if options are allowed, we'll have to account for that.\n    //*however*, in order to minimize the number of possibilities, we won't\n    //use these unless the last argument of inputs actually looks like an options!\n    const lastInput = inputs[inputs.length - 1];\n    let isOptionsPossible = true;\n\n    try {\n      const wrappedOptions = yield* wrap_1.wrap({\n        typeClass: \"options\"\n      }, lastInput, {\n        name: \"<options>\",\n        loose: true,\n        oldOptionsBehavior: true,\n        userDefinedTypes\n      });\n      possibleOptions = wrappedOptions.value;\n    } catch (error) {\n      if (error instanceof errors_1.TypeMismatchError) {\n        isOptionsPossible = false;\n      } else {\n        throw error; //rethrow unexpected errors\n      }\n    }\n\n    if (isOptionsPossible) {\n      possibleMatchesWithOptions = methods.filter(method => method.inputs.length === inputs.length - 1);\n    }\n  }\n\n  debug(\"possibleMatches: %o\", possibleMatches);\n  debug(\"possibleMatchesWithOptions: %o\", possibleMatchesWithOptions); //if there's now only one possibility, great!\n\n  if (possibleMatches.length === 1 && possibleMatchesWithOptions.length === 0) {\n    //only one possibility, no options. we can just defer to wrapMultiple.\n    //(again, point is to have good error messaging)\n    debug(\"only one possibility, no options\");\n    const method = possibleMatches[0];\n    return {\n      method,\n      arguments: yield* wrapMultiple(method.inputs, inputs, {\n        userDefinedTypes,\n        loose: true,\n        name: \"<arguments>\"\n      }),\n      options: {}\n    };\n  } else if (possibleMatchesWithOptions.length === 1 && possibleMatches.length === 0) {\n    //only one possibility, with options.  moreover, we already determined the options\n    //above, so we can once again just defer to wrapMultiple\n    debug(\"only one possiblity, with options\");\n    const method = possibleMatchesWithOptions[0];\n    return {\n      method,\n      arguments: yield* wrapMultiple(method.inputs, inputs, {\n        userDefinedTypes,\n        loose: true,\n        name: \"<arguments>\"\n      }),\n      options: possibleOptions\n    };\n  } else if (possibleMatches.length === 0 && possibleMatchesWithOptions.length === 0) {\n    debug(\"no possibilities\"); //nothing matches!\n\n    throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n  } //if all of our attempts to avoid it have failed, we'll have to actually use\n  //our overload resolution system. note how we do *not* turn on loose in this\n  //case!\n\n\n  debug(\"attempting overload resolution\");\n  let resolutions = [];\n\n  for (const method of methods) {\n    let wrapped;\n\n    try {\n      //note this part takes care of options for us...\n      //although yes this means options will be re-wrapped, oh well\n      wrapped = yield* wrapForMethodRaw(method, inputs, {\n        userDefinedTypes,\n        allowOptions\n      });\n    } catch (error) {\n      //if there's an error, don't add it\n      debug(\"failed: %O\", method);\n      debug(\"because: %O\", error);\n      continue;\n    } //note that options and arguments here are both not correct, but we'll\n    //fix them up later!\n\n\n    debug(\"adding: %O\", method);\n    resolutions.push({\n      method,\n      arguments: wrapped,\n      options: {}\n    });\n  } //now: narrow it down to the most specific one(s)\n\n\n  debug(\"resolutions: %O\", resolutions);\n  resolutions = resolutions.filter(resolution => resolutions.every(comparisonResolution => !priority_1.isMoreSpecificMultiple(comparisonResolution.arguments, resolution.arguments, userDefinedTypes) || //because the comparison is nonstrict, this comparison is added to\n  //effectively make it strict\n  // i.e. we have !(x<=y) but we want !(x<y), i.e.,\n  // !(x<=y) | x=y, i.e., !(x<=y) | (x<=y & y<=x),\n  // i.e., !(x<=y) | y<=x\n  priority_1.isMoreSpecificMultiple(resolution.arguments, comparisonResolution.arguments, userDefinedTypes)));\n  debug(\"resolutions remaining: %O\", resolutions);\n\n  switch (resolutions.length) {\n    case 0:\n      //no resolution worked\n      throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n\n    case 1:\n      //there was a most specific resolution; fix up options and arguments\n      //before returning\n      const {\n        method,\n        arguments: wrapped\n      } = resolutions[0];\n      return wrappingToResolution(method, wrapped);\n\n    default:\n      //no unique most-specific resolution\n      throw new errors_1.NoUniqueBestOverloadError(resolutions);\n  }\n}\n\nexports.resolveAndWrap = resolveAndWrap;","map":{"version":3,"mappings":"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","names":["debug","debug_1","Object","enumerable","get","errors_1","__exportStar","wrap_1","exports","wrapMultiple","types","inputs","wrapOptions","combinedType","typeClass","memberTypes","wrappedTogether","value","map","wrapForMethod","method","resolveOptions","wrapped","wrapForMethodRaw","wrappingToResolution","length","type","wrappedArguments","slice","options","arguments","userDefinedTypes","allowOptions","loose","oldOptionsBehavior","name","inputsWithOptions","orOneMore","resolveAndWrap","methods","possibleMatches","filter","possibleMatchesWithOptions","possibleOptions","lastInput","isOptionsPossible","wrappedOptions","error","resolutions","push","resolution","every","comparisonResolution","priority_1"],"sourceRoot":"","sources":["../../../lib/wrap/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
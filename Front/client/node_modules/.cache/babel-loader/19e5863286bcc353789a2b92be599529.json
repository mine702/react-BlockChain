{"ast":null,"code":"import { add64, isEqual64, isStrictlyPositive64, isStrictlySmaller64, substract64, Unit64 } from '../_internals/helpers/ArrayInt64.js';\nimport { arrayInt64 } from '../_internals/ArrayInt64Arbitrary.js';\nimport { doubleToIndex, indexToDouble } from '../_internals/helpers/DoubleHelpers.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\n\nfunction safeDoubleToIndex(d, constraintsLabel) {\n  if (Number.isNaN(d)) {\n    throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');\n  }\n\n  return doubleToIndex(d);\n}\n\nfunction unmapperDoubleToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return doubleToIndex(value);\n}\n\nexport function doubleNext() {\n  let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeDoubleToIndex(min, 'min');\n  const maxIndex = safeDoubleToIndex(max, 'max');\n\n  if (isStrictlySmaller64(maxIndex, minIndex)) {\n    throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return convertFromNext(convertToNext(arrayInt64(minIndex, maxIndex)).map(indexToDouble, unmapperDoubleToIndex));\n  }\n\n  const positiveMaxIdx = isStrictlyPositive64(maxIndex);\n  const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);\n  const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;\n  return convertFromNext(convertToNext(arrayInt64(minIndexWithNaN, maxIndexWithNaN)).map(index => {\n    if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex)) return Number.NaN;else return indexToDouble(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n    return doubleToIndex(value);\n  }));\n}","map":{"version":3,"names":["add64","isEqual64","isStrictlyPositive64","isStrictlySmaller64","substract64","Unit64","arrayInt64","doubleToIndex","indexToDouble","convertFromNext","convertToNext","safeDoubleToIndex","d","constraintsLabel","Number","isNaN","Error","unmapperDoubleToIndex","value","doubleNext","constraints","noDefaultInfinity","noNaN","min","MAX_VALUE","NEGATIVE_INFINITY","max","POSITIVE_INFINITY","minIndex","maxIndex","map","positiveMaxIdx","minIndexWithNaN","maxIndexWithNaN","index","NaN"],"sources":["C:/Users/cyr50/OneDrive/바탕 화면/비트고급 프로젝트_tuffle/Front/client/node_modules/fast-check/lib/esm/arbitrary/_next/doubleNext.js"],"sourcesContent":["import { add64, isEqual64, isStrictlyPositive64, isStrictlySmaller64, substract64, Unit64, } from '../_internals/helpers/ArrayInt64.js';\nimport { arrayInt64 } from '../_internals/ArrayInt64Arbitrary.js';\nimport { doubleToIndex, indexToDouble } from '../_internals/helpers/DoubleHelpers.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\nfunction safeDoubleToIndex(d, constraintsLabel) {\n    if (Number.isNaN(d)) {\n        throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');\n    }\n    return doubleToIndex(d);\n}\nfunction unmapperDoubleToIndex(value) {\n    if (typeof value !== 'number')\n        throw new Error('Unsupported type');\n    return doubleToIndex(value);\n}\nexport function doubleNext(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeDoubleToIndex(min, 'min');\n    const maxIndex = safeDoubleToIndex(max, 'max');\n    if (isStrictlySmaller64(maxIndex, minIndex)) {\n        throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return convertFromNext(convertToNext(arrayInt64(minIndex, maxIndex)).map(indexToDouble, unmapperDoubleToIndex));\n    }\n    const positiveMaxIdx = isStrictlyPositive64(maxIndex);\n    const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);\n    const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;\n    return convertFromNext(convertToNext(arrayInt64(minIndexWithNaN, maxIndexWithNaN)).map((index) => {\n        if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex))\n            return Number.NaN;\n        else\n            return indexToDouble(index);\n    }, (value) => {\n        if (typeof value !== 'number')\n            throw new Error('Unsupported type');\n        if (Number.isNaN(value))\n            return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n        return doubleToIndex(value);\n    }));\n}\n"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,SAAhB,EAA2BC,oBAA3B,EAAiDC,mBAAjD,EAAsEC,WAAtE,EAAmFC,MAAnF,QAAkG,qCAAlG;AACA,SAASC,UAAT,QAA2B,sCAA3B;AACA,SAASC,aAAT,EAAwBC,aAAxB,QAA6C,wCAA7C;AACA,SAASC,eAAT,EAA0BC,aAA1B,QAA+C,gDAA/C;;AACA,SAASC,iBAAT,CAA2BC,CAA3B,EAA8BC,gBAA9B,EAAgD;EAC5C,IAAIC,MAAM,CAACC,KAAP,CAAaH,CAAb,CAAJ,EAAqB;IACjB,MAAM,IAAII,KAAJ,CAAU,+BAA+BH,gBAA/B,GAAkD,yBAA5D,CAAN;EACH;;EACD,OAAON,aAAa,CAACK,CAAD,CAApB;AACH;;AACD,SAASK,qBAAT,CAA+BC,KAA/B,EAAsC;EAClC,IAAI,OAAOA,KAAP,KAAiB,QAArB,EACI,MAAM,IAAIF,KAAJ,CAAU,kBAAV,CAAN;EACJ,OAAOT,aAAa,CAACW,KAAD,CAApB;AACH;;AACD,OAAO,SAASC,UAAT,GAAsC;EAAA,IAAlBC,WAAkB,uEAAJ,EAAI;EACzC,MAAM;IAAEC,iBAAiB,GAAG,KAAtB;IAA6BC,KAAK,GAAG,KAArC;IAA4CC,GAAG,GAAGF,iBAAiB,GAAG,CAACP,MAAM,CAACU,SAAX,GAAuBV,MAAM,CAACW,iBAAjG;IAAoHC,GAAG,GAAGL,iBAAiB,GAAGP,MAAM,CAACU,SAAV,GAAsBV,MAAM,CAACa;EAAxK,IAA+LP,WAArM;EACA,MAAMQ,QAAQ,GAAGjB,iBAAiB,CAACY,GAAD,EAAM,KAAN,CAAlC;EACA,MAAMM,QAAQ,GAAGlB,iBAAiB,CAACe,GAAD,EAAM,KAAN,CAAlC;;EACA,IAAIvB,mBAAmB,CAAC0B,QAAD,EAAWD,QAAX,CAAvB,EAA6C;IACzC,MAAM,IAAIZ,KAAJ,CAAU,2EAAV,CAAN;EACH;;EACD,IAAIM,KAAJ,EAAW;IACP,OAAOb,eAAe,CAACC,aAAa,CAACJ,UAAU,CAACsB,QAAD,EAAWC,QAAX,CAAX,CAAb,CAA8CC,GAA9C,CAAkDtB,aAAlD,EAAiES,qBAAjE,CAAD,CAAtB;EACH;;EACD,MAAMc,cAAc,GAAG7B,oBAAoB,CAAC2B,QAAD,CAA3C;EACA,MAAMG,eAAe,GAAGD,cAAc,GAAGH,QAAH,GAAcxB,WAAW,CAACwB,QAAD,EAAWvB,MAAX,CAA/D;EACA,MAAM4B,eAAe,GAAGF,cAAc,GAAG/B,KAAK,CAAC6B,QAAD,EAAWxB,MAAX,CAAR,GAA6BwB,QAAnE;EACA,OAAOpB,eAAe,CAACC,aAAa,CAACJ,UAAU,CAAC0B,eAAD,EAAkBC,eAAlB,CAAX,CAAb,CAA4DH,GAA5D,CAAiEI,KAAD,IAAW;IAC9F,IAAI/B,mBAAmB,CAAC0B,QAAD,EAAWK,KAAX,CAAnB,IAAwC/B,mBAAmB,CAAC+B,KAAD,EAAQN,QAAR,CAA/D,EACI,OAAOd,MAAM,CAACqB,GAAd,CADJ,KAGI,OAAO3B,aAAa,CAAC0B,KAAD,CAApB;EACP,CALsB,EAKnBhB,KAAD,IAAW;IACV,IAAI,OAAOA,KAAP,KAAiB,QAArB,EACI,MAAM,IAAIF,KAAJ,CAAU,kBAAV,CAAN;IACJ,IAAIF,MAAM,CAACC,KAAP,CAAaG,KAAb,CAAJ,EACI,OAAO,CAACjB,SAAS,CAAC4B,QAAD,EAAWI,eAAX,CAAV,GAAwCA,eAAxC,GAA0DD,eAAjE;IACJ,OAAOzB,aAAa,CAACW,KAAD,CAApB;EACH,CAXsB,CAAD,CAAtB;AAYH"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:storage:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeStorage(dataType, pointer, info) {\n  if (Format.Types.isReferenceType(dataType)) {\n    return yield* decodeStorageReference(dataType, pointer, info);\n  } else {\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n  }\n}\n\nexports.decodeStorage = decodeStorage; //decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\n\nfunction* decodeStorageReferenceByAddress(dataType, pointer, info) {\n  const allocations = info.allocations.storage;\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, info.state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  }\n\n  const startOffset = Conversion.toBN(rawValue);\n  let rawSize;\n\n  try {\n    rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  } //we *know* the type being decoded must be sized in words, because it's a\n  //reference type, but TypeScript doesn't, so we'll have to use a type\n  //coercion\n\n\n  const size = rawSize.words; //now, construct the storage pointer\n\n  const newPointer = {\n    location: \"storage\",\n    range: {\n      from: {\n        slot: {\n          offset: startOffset\n        },\n        index: 0\n      },\n      to: {\n        slot: {\n          offset: startOffset.addn(size - 1)\n        },\n        index: Evm.Utils.WORD_SIZE - 1\n      }\n    }\n  }; //dispatch to decodeStorageReference\n\n  return yield* decodeStorageReference(dataType, newPointer, info);\n}\n\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\n\nfunction* decodeStorageReference(dataType, pointer, info) {\n  var data;\n  var length;\n  const {\n    state\n  } = info;\n  const allocations = info.allocations.storage;\n\n  switch (dataType.typeClass) {\n    case \"array\":\n      {\n        debug(\"storage array! %o\", pointer);\n        let lengthAsBN;\n\n        switch (dataType.kind) {\n          case \"dynamic\":\n            debug(\"dynamic array\");\n            debug(\"type %O\", dataType);\n\n            try {\n              data = yield* read_1.default(pointer, state);\n            } catch (error) {\n              return errors_1.handleDecodingError(dataType, error);\n            }\n\n            lengthAsBN = Conversion.toBN(data);\n            break;\n\n          case \"static\":\n            debug(\"static array\");\n            lengthAsBN = dataType.length;\n            break;\n        }\n\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_a) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n\n        debug(\"length %o\", length);\n        debug(\"about to determine baseSize\");\n        let baseSize;\n\n        try {\n          baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        debug(\"baseSize %o\", baseSize); //we are going to make a list of child ranges, pushing them one by one onto\n        //this list, and then decode them; the first part will vary based on whether\n        //we're in the words case or the bytes case, the second will not\n\n        let ranges = [];\n\n        if (Utils.isWordsLength(baseSize)) {\n          //currentSlot will point to the start of the entry being decoded\n          let currentSlot = {\n            path: pointer.range.from.slot,\n            offset: new bn_js_1.default(0),\n            hashPath: dataType.kind === \"dynamic\"\n          };\n\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.clone(),\n                  hashPath: currentSlot.hashPath\n                },\n                index: 0\n              },\n              to: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.addn(baseSize.words - 1),\n                  hashPath: currentSlot.hashPath\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n              }\n            };\n            ranges.push(childRange);\n            currentSlot.offset.iaddn(baseSize.words);\n          }\n        } else {\n          const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n          debug(\"perWord %d\", perWord); //currentPosition will point to the start of the entry being decoded\n          //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n\n          let currentPosition = {\n            slot: {\n              path: pointer.range.from.slot,\n              offset: new bn_js_1.default(0),\n              hashPath: dataType.kind === \"dynamic\"\n            },\n            index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n\n          };\n\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentPosition.slot.path,\n                  offset: currentPosition.slot.offset.clone(),\n                  hashPath: currentPosition.slot.hashPath\n                },\n                index: currentPosition.index\n              },\n              length: baseSize.bytes\n            };\n            ranges.push(childRange);\n            currentPosition.index -= baseSize.bytes;\n\n            if (currentPosition.index < 0) {\n              currentPosition.slot.offset.iaddn(1);\n              currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n            }\n          }\n        }\n\n        let decodedChildren = [];\n\n        for (let childRange of ranges) {\n          decodedChildren.push(yield* decodeStorage(dataType.baseType, {\n            location: \"storage\",\n            range: childRange\n          }, info));\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      }\n\n    case \"bytes\":\n    case \"string\":\n      {\n        try {\n          data = yield* read_1.default(pointer, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        let lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n\n        if (lengthByte % 2 == 0) {\n          // string lives in word, length is last byte / 2\n          length = lengthByte / 2;\n          debug(\"in-word; length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: pointer.range.from.slot,\n                index: 0\n              },\n              to: {\n                slot: pointer.range.from.slot,\n                index: length - 1\n              }\n            }\n          }, info);\n        } else {\n          let lengthAsBN = Conversion.toBN(data).subn(1).divn(2);\n\n          try {\n            length = lengthAsBN.toNumber();\n          } catch (_b) {\n            return {\n              //again with the TS failures...\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"OverlongArraysAndStringsNotImplementedError\",\n                lengthAsBN\n              }\n            };\n          }\n\n          debug(\"new-word, length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  path: pointer.range.from.slot,\n                  offset: new bn_js_1.default(0),\n                  hashPath: true\n                },\n                index: 0\n              },\n              length\n            }\n          }, info);\n        }\n      }\n\n    case \"struct\":\n      {\n        const typeId = dataType.id;\n        const structAllocation = allocations[typeId];\n\n        if (!structAllocation) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          };\n        }\n\n        let decodedMembers = [];\n        const members = structAllocation.members;\n\n        for (let index = 0; index < members.length; index++) {\n          const memberAllocation = members[index];\n          const memberPointer = memberAllocation.pointer; //the type system thinks memberPointer might also be a constant\n          //definition pointer.  However, structs can't contain constants,\n          //so *we* know it's not, and can safely coerce it.\n\n          debug(\"pointer %O\", pointer);\n          const childRange = {\n            from: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.from.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.from.index\n            },\n            to: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.to.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.to.index\n            }\n          };\n          let storedType = info.userDefinedTypes[typeId];\n\n          if (!storedType) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"UserDefinedTypeNotFoundError\",\n                type: dataType\n              }\n            };\n          }\n\n          let storedMemberType = storedType.memberTypes[index].type;\n          let memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n          decodedMembers.push({\n            name: memberAllocation.name,\n            value: yield* decodeStorage(memberType, {\n              location: \"storage\",\n              range: childRange\n            }, info)\n          });\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedMembers\n        };\n      }\n\n    case \"mapping\":\n      {\n        debug(\"decoding mapping\");\n        const valueType = dataType.valueType;\n        let valueSize;\n\n        try {\n          valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        let decodedEntries = [];\n        const baseSlot = pointer.range.from.slot;\n        debug(\"baseSlot %o\", baseSlot);\n        debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n        const keySlots = info.mappingKeys.filter(_ref => {\n          let {\n            path\n          } = _ref;\n          return Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path));\n        });\n\n        for (const {\n          key\n        } of keySlots) {\n          let valuePointer;\n\n          if (Utils.isWordsLength(valueSize)) {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(valueSize.words - 1)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          } else {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          }\n\n          decodedEntries.push({\n            key,\n            value: yield* decodeStorage(valueType, valuePointer, info)\n          });\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedEntries\n        };\n      }\n  }\n}\n\nexports.decodeStorageReference = decodeStorageReference;","map":{"version":3,"mappings":"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","names":["debug","debug_1","decodeStorage","dataType","pointer","info","Format","Types","isReferenceType","decodeStorageReference","Basic","Decode","decodeBasic","exports","decodeStorageReferenceByAddress","allocations","storage","rawValue","read_1","state","error","errors_1","startOffset","Conversion","toBN","rawSize","allocate_1","userDefinedTypes","currentContext","compiler","size","words","newPointer","location","range","from","slot","offset","index","to","addn","Evm","Utils","WORD_SIZE","data","length","typeClass","lengthAsBN","kind","toNumber","type","baseSize","baseType","ranges","isWordsLength","currentSlot","path","bn_js_1","hashPath","i","childRange","clone","push","iaddn","perWord","Math","floor","bytes","currentPosition","decodedChildren","value","lengthByte","Bytes","decodeBytes","subn","divn","typeId","id","structAllocation","decodedMembers","members","memberAllocation","memberPointer","storedType","storedMemberType","memberTypes","memberType","specifyLocation","name","valueType","valueSize","decodedEntries","baseSlot","slotAddress","keySlots","mappingKeys","filter","eq","key","valuePointer"],"sourceRoot":"","sources":["../../../../lib/storage/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"const OS = require(\"os\");\n\nconst debug = require(\"debug\")(\"debug-utils\");\n\nconst util = require(\"util\");\n\nconst Codec = require(\"@truffle/codec\");\n\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\n\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\n\nhljsDefineSolidity(chromafi.hljs);\n\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\nconst commandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step line / step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  \"p\": \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  \"l\": \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  \"h\": \"print this help\",\n  \"v\": \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  \"b\": \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  \"B\": \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  \"c\": \"continue until breakpoint\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load new transaction\",\n  \"T\": \"unload transaction\",\n  \"s\": \"print stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources except via `;`\",\n  \"y\": \"(if at end) reset & continue to final error\",\n  \"Y\": \"reset & continue to previous error\"\n};\nconst shortCommandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction\",\n  \"p\": \"print state\",\n  \"l\": \"print context\",\n  \"h\": \"print help\",\n  \"v\": \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  \"b\": \"add breakpoint\",\n  \"B\": \"remove breakpoint\",\n  \"c\": \"continue\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load\",\n  \"T\": \"unload\",\n  \"s\": \"stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources\",\n  \"y\": \"reset & go to final error\",\n  \"Y\": \"reset & go to previous error\"\n};\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\nconst DEFAULT_TAB_WIDTH = 8;\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  \"base\": chalk,\n  \"lineNumbers\": chalk,\n  \"trailingSpace\": chalk,\n\n  /* classes hljs-solidity actually uses */\n  \"keyword\": truffleColors.mint,\n  \"number\": truffleColors.red,\n  \"string\": truffleColors.green,\n  \"params\": truffleColors.pink,\n  \"builtIn\": truffleColors.watermelon,\n  \"built_in\": truffleColors.watermelon,\n  //just to be sure\n  \"literal\": truffleColors.watermelon,\n  \"function\": truffleColors.orange,\n  \"title\": truffleColors.orange,\n  \"class\": truffleColors.orange,\n  \"comment\": truffleColors.comment,\n  \"doctag\": truffleColors.comment,\n  \"operator\": truffleColors.blue,\n  \"punctuation\": truffleColors.purple,\n\n  /* classes it might soon use! */\n  \"meta\": truffleColors.pink,\n  \"metaString\": truffleColors.green,\n  \"meta-string\": truffleColors.green,\n  //similar\n\n  /* classes it doesn't currently use but notionally could */\n  \"type\": truffleColors.orange,\n  \"symbol\": truffleColors.orange,\n  \"metaKeyword\": truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint,\n  //again, to be sure\n  \"property\": chalk,\n  //not putting any highlighting here for now\n\n  /* classes that don't make sense for Solidity */\n  \"regexp\": chalk,\n  //solidity does not have regexps\n  \"subst\": chalk,\n  //or string interpolation\n  \"name\": chalk,\n  //or s-expressions\n  \"builtInName\": chalk,\n  //or s-expressions, again\n  \"builtin-name\": chalk,\n  //just to be sure\n\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  \"section\": chalk,\n  \"tag\": chalk,\n  \"attr\": chalk,\n  \"attribute\": chalk,\n  \"variable\": chalk,\n  \"bullet\": chalk,\n  \"code\": chalk,\n  \"emphasis\": chalk,\n  \"strong\": chalk,\n  \"formula\": chalk,\n  \"link\": chalk,\n  \"quote\": chalk,\n  \"selectorAttr\": chalk,\n  //lotta redundancy follows\n  \"selector-attr\": chalk,\n  \"selectorClass\": chalk,\n  \"selector-class\": chalk,\n  \"selectorId\": chalk,\n  \"selector-id\": chalk,\n  \"selectorPseudo\": chalk,\n  \"selector-pseudo\": chalk,\n  \"selectorTag\": chalk,\n  \"selector-tag\": chalk,\n  \"templateTag\": chalk,\n  \"template-tag\": chalk,\n  \"templateVariable\": chalk,\n  \"template-variable\": chalk,\n  \"addition\": chalk,\n  \"deletion\": chalk\n};\nvar DebugUtils = {\n  truffleColors,\n  //make these externally available\n  //panicCode may be either a number, BN, or decimal string\n  panicString: function (panicCode) {\n    let verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n\n    return verbose ? verbosePanicTable[panicCode] || verboseUnknownString : panicTable[panicCode] || unknownString;\n  },\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    } //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n\n\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    const lowestInternalIndex = Math.min(...compilation.contracts.map(contract => {\n      //find first defined index\n      let lowestConstructor = (contract.generatedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestConstructor === -1) {\n        lowestConstructor = Infinity;\n      }\n\n      let lowestDeployed = (contract.deployedGeneratedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestDeployed === -1) {\n        lowestDeployed = Infinity;\n      }\n\n      return Math.min(lowestConstructor, lowestDeployed);\n    }));\n\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    } //check #4: are there any AST ID collisions?\n\n\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occurred twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    }; //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n\n\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(source => !source || source.language !== \"Solidity\" || allIDsUnseenSoFar(source.ast));\n  },\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n  formatCommandDescription: function (commandId) {\n    return truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId];\n  },\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined ? `debug(${network}:${txHash.substring(0, 10)}...)> ` : `debug(${network})> `;\n  },\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(`${chalk.bold(\"Warning:\")} The source code for one or more contracts could not be found.`);\n    }\n\n    return lines.join(OS.EOL);\n  },\n  formatHelp: function () {\n    let lastCommand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"n\";\n    var prefix = [\"Commands:\", truffleColors.mint(\"(enter)\") + \" last command entered (\" + shortCommandReference[lastCommand] + \")\"];\n    var commandSections = [[\"o\", \"i\", \"u\", \"n\"], [\"c\", \"Y\"], [\"y\"], [\";\"], [\"g\", \"G\"], [\"p\"], [\"l\"], [\"s\", \"h\"], [\"q\", \"r\", \"t\", \"T\"], [\"b\"], [\"B\"], [\"+\", \"-\"], [\"?\"], [\"v\"], [\":\"]].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n    var suffix = [\"\"];\n    var lines = prefix.concat(commandSections).concat(suffix);\n    return lines.join(OS.EOL);\n  },\n  tabsToSpaces: function (inputLine) {\n    let tabLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TAB_WIDTH;\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n\n    return line;\n  },\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n    return prefix + line;\n  },\n  formatLinePointer: function (line, startCol, endCol, padding) {\n    let tabLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_TAB_WIDTH;\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n      let additional;\n\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (source, range, uncolorizedSource) {\n    let contextBefore = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    let contextAfter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n    //note: beforeLines now includes the line itself\n\n    var beforeLines = source.slice(startIndex, range.start.line + 1).map((line, index) => {\n      let number = startIndex + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var afterLines = source.slice(range.start.line + 1, endIndex + 1).map((line, index) => {\n      let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var pointerStart = range.start.column;\n    var pointerEnd;\n    let uncolorizedLine = uncolorizedSource[range.start.line]; // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat([DebugUtils.formatLinePointer( //the line-pointer formatter doesn't work right with colorized\n    //lines, so we pass in the uncolored version\n    uncolorizedLine, pointerStart, pointerEnd, prefixLength)], afterLines);\n    return allLines.join(OS.EOL);\n  },\n  formatBreakpointLocation: function (breakpoint, here, currentSourceId, sourceNames) {\n    let baseMessage;\n\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here ? `this point in line ${breakpoint.line + 1}` : `a point in line ${breakpoint.line + 1}`; //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"));\n  },\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(2, ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n    let formatted = slots.map((slot, index) => {\n      if (index === 0 || !Codec.Conversion.toBN(slot).eq(Codec.Conversion.toBN(slots[index - 1]).addn(1))) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n\n    for (let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE; wordIndex < calldata.length; wordIndex += Codec.Evm.Utils.WORD_SIZE) {\n      words.push(calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE));\n    }\n\n    let maxWordIndex = (words.length - 1) * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n\n    let formattedSelector;\n\n    if (selector.length > 0) {\n      formattedSelector = \"Calldata:\\n\" + `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` + truffleColors.pink(Codec.Conversion.toHexString(selector).slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \"));\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word).slice(2).padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n    formatted.unshift(formattedSelector);\n    return formatted.join(OS.EOL);\n  },\n  formatValue: function (value) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let nativized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized ? value : new Codec.Export.ResultInspector(value);\n    return util.inspect(valueToInspect, inspectOptions).split(/\\r?\\n/g).map((line, i) => {\n      // don't indent first line\n      const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n      return padding + line;\n    }).join(OS.EOL);\n  },\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    const name = decoding.definedIn ? `${decoding.definedIn.typeName}.${decoding.abi.name}` : decoding.abi.name;\n    return Codec.Export.formatFunctionLike(name, decoding.arguments, inspectOptions, false, indent);\n  },\n  formatStacktrace: function (stacktrace) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    //get message or panic code from stacktrace\n    const {\n      message,\n      panic,\n      custom\n    } = stacktrace[0]; //we want to print inner to outer, so first, let's\n    //reverse\n\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n\n    let lines = stacktrace.map(_ref => {\n      let {\n        functionName,\n        contractName,\n        address,\n        location,\n        isConstructor,\n        type\n      } = _ref;\n      let name;\n\n      if (contractName && functionName) {\n        name = `${contractName}.${functionName}`;\n      } else if (contractName) {\n        name = type === \"external\" && isConstructor ? `new ${contractName}` : contractName; //for internal calls, it doesn't really make sense\n        //to write \"new Contract\"\n      } else if (functionName) {\n        name = functionName;\n      } else {\n        name = \"unknown function\";\n      }\n\n      let locationString;\n\n      if (location) {\n        let {\n          source: {\n            sourcePath\n          },\n          sourceRange: {\n            lines: {\n              start: {\n                line,\n                column\n              }\n            }\n          }\n        } = location;\n        locationString = sourcePath ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n        : \"unknown location\";\n      } else {\n        locationString = \"unknown location\";\n      }\n\n      let addressString = type === \"external\" ? address !== undefined ? ` [address ${address}]` : \" [unknown address]\" : \"\";\n      return `at ${name}${addressString} (${locationString})`;\n    });\n    let status = stacktrace[0].status;\n\n    if (status != undefined) {\n      let statusLine;\n\n      if (message !== undefined) {\n        statusLine = status ? `Error: Improper return (caused message: ${message})` : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status ? `Panic: Improper return (caused ${DebugUtils.panicString(panic).toLowerCase()} (code 0x${panic.toString(16)}))` : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(16)})`;\n      } else if (custom !== undefined) {\n        statusLine = status ? `Error: Improper return (caused custom error)` : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status ? \"Error: Improper return (may be an unexpected self-destruct)\" : \"Error: Revert or exceptional halt\";\n      }\n\n      lines.unshift(statusLine);\n    }\n\n    let indented = lines.map((line, index) => index === 0 ? line : \" \".repeat(indent) + line);\n    return indented.join(OS.EOL);\n  },\n  colorize: function (code) {\n    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Solidity\";\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false,\n      //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n    };\n\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n\n        return chromafi(code, options);\n\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n\n        return chromafi(code, options);\n\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign({}, ...Object.entries(variables).map(_ref2 => {\n      let [variable, value] = _ref2;\n      return variable === \"this\" ? {\n        [replacement]: value\n      } : {\n        [variable]: value\n      };\n    }));\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const {\n      controller\n    } = bugger.selectors;\n\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const {\n        compilationId,\n        id,\n        internal\n      } = source; //stepInto should skip internal sources, but there still might be\n      //one at the end\n\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = { ...sources[compilationId],\n          [id]: source\n        };\n      }\n\n      await bugger.stepInto();\n    }\n\n    await bugger.reset(); //flatten sources before returning\n\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\nmodule.exports = DebugUtils;","map":{"version":3,"names":["OS","require","debug","util","Codec","BN","chromafi","hljsDefineSolidity","hljs","chalk","panicTable","verbosePanicTable","commandReference","shortCommandReference","truffleColors","mint","hex","orange","pink","purple","green","red","yellow","blue","comment","hsl","watermelon","periwinkle","DEFAULT_TAB_WIDTH","trufflePalette","DebugUtils","panicString","panicCode","verbose","unknownString","verboseUnknownString","isBN","toNumber","_","isUsableCompilation","compilation","unreliableSourceOrder","sources","includes","undefined","lowestInternalIndex","Math","min","contracts","map","contract","lowestConstructor","generatedSources","findIndex","x","Infinity","lowestDeployed","deployedGeneratedSources","length","astIds","Set","allIDsUnseenSoFar","node","Array","isArray","every","id","has","add","Object","values","source","language","ast","formatStartMessage","withTransaction","formatTransactionStartMessage","formatCommandDescription","commandId","formatPrompt","network","txHash","substring","formatAffectedInstances","instances","hasAllSource","lines","keys","address","instance","contractName","push","bold","join","EOL","formatHelp","lastCommand","prefix","commandSections","shortcuts","suffix","concat","tabsToSpaces","inputLine","tabLength","line","counter","i","remaining","repeat","formatLineNumberPrefix","number","cols","String","padStart","formatLinePointer","startCol","endCol","padding","output","pointedAt","additional","replace","formatRangeLines","range","uncolorizedSource","contextBefore","contextAfter","startIndex","max","start","endIndex","prefixLength","beforeLines","slice","index","afterLines","pointerStart","column","pointerEnd","uncolorizedLine","end","allLines","formatBreakpointLocation","breakpoint","here","currentSourceId","sourceNames","baseMessage","sourceId","sourceName","formatCurrentInstruction","instruction","pc","formatPC","formattedInstruction","formatInstruction","name","pushData","toString","formatStack","stack","formatted","item","unshift","formatMemory","memory","maxPrefixLength","Evm","Utils","WORD_SIZE","word","formatStorage","storage","slots","sort","slot","Conversion","toBN","eq","addn","formatCalldata","calldata","selector","SELECTOR_SIZE","words","wordIndex","maxWordIndex","formattedSelector","toHexString","data","padEnd","formatValue","value","indent","nativized","inspectOptions","colors","depth","maxArrayLength","breakLength","valueToInspect","Export","ResultInspector","inspect","split","formatCustomError","decoding","definedIn","typeName","abi","formatFunctionLike","arguments","formatStacktrace","stacktrace","message","panic","custom","reverse","functionName","location","isConstructor","type","locationString","sourcePath","sourceRange","addressString","status","statusLine","toLowerCase","indented","colorize","code","options","lang","lineNumbers","stripIndent","codePad","lineEndPad","cleanThis","variables","replacement","assign","entries","variable","getTransactionSourcesBeforeStarting","bugger","reset","controller","selectors","view","current","trace","finished","compilationId","internal","stepInto","module","exports"],"sources":["C:/Users/cyr50/OneDrive/바탕 화면/비트고급 프로젝트_tuffle/Front/client/node_modules/@truffle/debug-utils/index.js"],"sourcesContent":["const OS = require(\"os\");\nconst debug = require(\"debug\")(\"debug-utils\");\nconst util = require(\"util\");\nconst Codec = require(\"@truffle/codec\");\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\nhljsDefineSolidity(chromafi.hljs);\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\n\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\n\nconst commandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step line / step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  \"p\": \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  \"l\": \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  \"h\": \"print this help\",\n  \"v\": \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  \"b\": \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  \"B\": \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  \"c\": \"continue until breakpoint\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load new transaction\",\n  \"T\": \"unload transaction\",\n  \"s\": \"print stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources except via `;`\",\n  \"y\": \"(if at end) reset & continue to final error\",\n  \"Y\": \"reset & continue to previous error\"\n};\n\nconst shortCommandReference = {\n  \"o\": \"step over\",\n  \"i\": \"step into\",\n  \"u\": \"step out\",\n  \"n\": \"step next\",\n  \";\": \"step instruction\",\n  \"p\": \"print state\",\n  \"l\": \"print context\",\n  \"h\": \"print help\",\n  \"v\": \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  \"b\": \"add breakpoint\",\n  \"B\": \"remove breakpoint\",\n  \"c\": \"continue\",\n  \"q\": \"quit\",\n  \"r\": \"reset\",\n  \"t\": \"load\",\n  \"T\": \"unload\",\n  \"s\": \"stacktrace\",\n  \"g\": \"turn on generated sources\",\n  \"G\": \"turn off generated sources\",\n  \"y\": \"reset & go to final error\",\n  \"Y\": \"reset & go to previous error\"\n};\n\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\n\nconst DEFAULT_TAB_WIDTH = 8;\n\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  \"base\": chalk,\n  \"lineNumbers\": chalk,\n  \"trailingSpace\": chalk,\n  /* classes hljs-solidity actually uses */\n  \"keyword\": truffleColors.mint,\n  \"number\": truffleColors.red,\n  \"string\": truffleColors.green,\n  \"params\": truffleColors.pink,\n  \"builtIn\": truffleColors.watermelon,\n  \"built_in\": truffleColors.watermelon, //just to be sure\n  \"literal\": truffleColors.watermelon,\n  \"function\": truffleColors.orange,\n  \"title\": truffleColors.orange,\n  \"class\": truffleColors.orange,\n  \"comment\": truffleColors.comment,\n  \"doctag\": truffleColors.comment,\n  \"operator\": truffleColors.blue,\n  \"punctuation\": truffleColors.purple,\n  /* classes it might soon use! */\n  \"meta\": truffleColors.pink,\n  \"metaString\": truffleColors.green,\n  \"meta-string\": truffleColors.green, //similar\n  /* classes it doesn't currently use but notionally could */\n  \"type\": truffleColors.orange,\n  \"symbol\": truffleColors.orange,\n  \"metaKeyword\": truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint, //again, to be sure\n  \"property\": chalk, //not putting any highlighting here for now\n  /* classes that don't make sense for Solidity */\n  \"regexp\": chalk, //solidity does not have regexps\n  \"subst\": chalk, //or string interpolation\n  \"name\": chalk, //or s-expressions\n  \"builtInName\": chalk, //or s-expressions, again\n  \"builtin-name\": chalk, //just to be sure\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  \"section\": chalk,\n  \"tag\": chalk,\n  \"attr\": chalk,\n  \"attribute\": chalk,\n  \"variable\": chalk,\n  \"bullet\": chalk,\n  \"code\": chalk,\n  \"emphasis\": chalk,\n  \"strong\": chalk,\n  \"formula\": chalk,\n  \"link\": chalk,\n  \"quote\": chalk,\n  \"selectorAttr\": chalk, //lotta redundancy follows\n  \"selector-attr\": chalk,\n  \"selectorClass\": chalk,\n  \"selector-class\": chalk,\n  \"selectorId\": chalk,\n  \"selector-id\": chalk,\n  \"selectorPseudo\": chalk,\n  \"selector-pseudo\": chalk,\n  \"selectorTag\": chalk,\n  \"selector-tag\": chalk,\n  \"templateTag\": chalk,\n  \"template-tag\": chalk,\n  \"templateVariable\": chalk,\n  \"template-variable\": chalk,\n  \"addition\": chalk,\n  \"deletion\": chalk\n};\n\nvar DebugUtils = {\n  truffleColors, //make these externally available\n\n  //panicCode may be either a number, BN, or decimal string\n  panicString: function (panicCode, verbose = false) {\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n    return verbose\n      ? verbosePanicTable[panicCode] || verboseUnknownString\n      : panicTable[panicCode] || unknownString;\n  },\n\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    }\n\n    //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    const lowestInternalIndex = Math.min(\n      ...compilation.contracts.map(contract => {\n        //find first defined index\n        let lowestConstructor = (contract.generatedSources || []).findIndex(\n          x => x !== undefined\n        );\n        if (lowestConstructor === -1) {\n          lowestConstructor = Infinity;\n        }\n        let lowestDeployed = (\n          contract.deployedGeneratedSources || []\n        ).findIndex(x => x !== undefined);\n        if (lowestDeployed === -1) {\n          lowestDeployed = Infinity;\n        }\n        return Math.min(lowestConstructor, lowestDeployed);\n      })\n    );\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    }\n\n    //check #4: are there any AST ID collisions?\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occurred twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    };\n\n    //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(\n      source =>\n        !source ||\n        source.language !== \"Solidity\" ||\n        allIDsUnseenSoFar(source.ast)\n    );\n  },\n\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n\n  formatCommandDescription: function (commandId) {\n    return (\n      truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId]\n    );\n  },\n\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined\n      ? `debug(${network}:${txHash.substring(0, 10)}...)> `\n      : `debug(${network})> `;\n  },\n\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\n        `${chalk.bold(\n          \"Warning:\"\n        )} The source code for one or more contracts could not be found.`\n      );\n    }\n\n    return lines.join(OS.EOL);\n  },\n\n  formatHelp: function (lastCommand = \"n\") {\n    var prefix = [\n      \"Commands:\",\n      truffleColors.mint(\"(enter)\") +\n        \" last command entered (\" +\n        shortCommandReference[lastCommand] +\n        \")\"\n    ];\n\n    var commandSections = [\n      [\"o\", \"i\", \"u\", \"n\"],\n      [\"c\", \"Y\"],\n      [\"y\"],\n      [\";\"],\n      [\"g\", \"G\"],\n      [\"p\"],\n      [\"l\"],\n      [\"s\", \"h\"],\n      [\"q\", \"r\", \"t\", \"T\"],\n      [\"b\"],\n      [\"B\"],\n      [\"+\", \"-\"],\n      [\"?\"],\n      [\"v\"],\n      [\":\"]\n    ].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n\n    var suffix = [\"\"];\n\n    var lines = prefix.concat(commandSections).concat(suffix);\n\n    return lines.join(OS.EOL);\n  },\n\n  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n    return line;\n  },\n\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n\n    return prefix + line;\n  },\n\n  formatLinePointer: function (\n    line,\n    startCol,\n    endCol,\n    padding,\n    tabLength = DEFAULT_TAB_WIDTH\n  ) {\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n\n      let additional;\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (\n    source,\n    range,\n    uncolorizedSource,\n    contextBefore = 2,\n    contextAfter = 0\n  ) {\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n\n    //note: beforeLines now includes the line itself\n    var beforeLines = source\n      .slice(startIndex, range.start.line + 1)\n      .map((line, index) => {\n        let number = startIndex + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n    var afterLines = source\n      .slice(range.start.line + 1, endIndex + 1)\n      .map((line, index) => {\n        let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n\n    var pointerStart = range.start.column;\n    var pointerEnd;\n\n    let uncolorizedLine = uncolorizedSource[range.start.line];\n\n    // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat(\n      [\n        DebugUtils.formatLinePointer(\n          //the line-pointer formatter doesn't work right with colorized\n          //lines, so we pass in the uncolored version\n          uncolorizedLine,\n          pointerStart,\n          pointerEnd,\n          prefixLength\n        )\n      ],\n      afterLines\n    );\n\n    return allLines.join(OS.EOL);\n  },\n\n  formatBreakpointLocation: function (\n    breakpoint,\n    here,\n    currentSourceId,\n    sourceNames\n  ) {\n    let baseMessage;\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here\n        ? `this point in line ${breakpoint.line + 1}`\n        : `a point in line ${breakpoint.line + 1}`;\n      //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(\n      instruction.name + \" \" + (instruction.pushData || \"\")\n    );\n  },\n\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(\n      2,\n      ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length\n    );\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE)\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n\n    let formatted = slots.map((slot, index) => {\n      if (\n        index === 0 ||\n        !Codec.Conversion.toBN(slot).eq(\n          Codec.Conversion.toBN(slots[index - 1]).addn(1)\n        )\n      ) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n    for (\n      let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE;\n      wordIndex < calldata.length;\n      wordIndex += Codec.Evm.Utils.WORD_SIZE\n    ) {\n      words.push(\n        calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE)\n      );\n    }\n    let maxWordIndex =\n      (words.length - 1) * Codec.Evm.Utils.WORD_SIZE +\n      Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n    let formattedSelector;\n    if (selector.length > 0) {\n      formattedSelector =\n        \"Calldata:\\n\" +\n        `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` +\n        truffleColors.pink(\n          Codec.Conversion.toHexString(selector)\n            .slice(2)\n            .padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \")\n        );\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (\n        index * Codec.Evm.Utils.WORD_SIZE +\n        Codec.Evm.Utils.SELECTOR_SIZE\n      )\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word)\n        .slice(2)\n        .padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n\n    formatted.unshift(formattedSelector);\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatValue: function (value, indent = 0, nativized = false) {\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized\n      ? value\n      : new Codec.Export.ResultInspector(value);\n    return util\n      .inspect(valueToInspect, inspectOptions)\n      .split(/\\r?\\n/g)\n      .map((line, i) => {\n        // don't indent first line\n        const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n        return padding + line;\n      })\n      .join(OS.EOL);\n  },\n\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding, indent = 0) {\n    const inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    const name = decoding.definedIn\n      ? `${decoding.definedIn.typeName}.${decoding.abi.name}`\n      : decoding.abi.name;\n    return Codec.Export.formatFunctionLike(\n      name,\n      decoding.arguments,\n      inspectOptions,\n      false,\n      indent\n    );\n  },\n\n  formatStacktrace: function (stacktrace, indent = 2) {\n    //get message or panic code from stacktrace\n    const { message, panic, custom } = stacktrace[0];\n    //we want to print inner to outer, so first, let's\n    //reverse\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n    let lines = stacktrace.map(\n      ({\n        functionName,\n        contractName,\n        address,\n        location,\n        isConstructor,\n        type\n      }) => {\n        let name;\n        if (contractName && functionName) {\n          name = `${contractName}.${functionName}`;\n        } else if (contractName) {\n          name =\n            type === \"external\" && isConstructor\n              ? `new ${contractName}`\n              : contractName;\n          //for internal calls, it doesn't really make sense\n          //to write \"new Contract\"\n        } else if (functionName) {\n          name = functionName;\n        } else {\n          name = \"unknown function\";\n        }\n        let locationString;\n        if (location) {\n          let {\n            source: { sourcePath },\n            sourceRange: {\n              lines: {\n                start: { line, column }\n              }\n            }\n          } = location;\n          locationString = sourcePath\n            ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n            : \"unknown location\";\n        } else {\n          locationString = \"unknown location\";\n        }\n        let addressString =\n          type === \"external\"\n            ? address !== undefined\n              ? ` [address ${address}]`\n              : \" [unknown address]\"\n            : \"\";\n        return `at ${name}${addressString} (${locationString})`;\n      }\n    );\n    let status = stacktrace[0].status;\n    if (status != undefined) {\n      let statusLine;\n      if (message !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused message: ${message})`\n          : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status\n          ? `Panic: Improper return (caused ${DebugUtils.panicString(\n              panic\n            ).toLowerCase()} (code 0x${panic.toString(16)}))`\n          : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(\n              16\n            )})`;\n      } else if (custom !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused custom error)`\n          : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status\n          ? \"Error: Improper return (may be an unexpected self-destruct)\"\n          : \"Error: Revert or exceptional halt\";\n      }\n      lines.unshift(statusLine);\n    }\n    let indented = lines.map((line, index) =>\n      index === 0 ? line : \" \".repeat(indent) + line\n    );\n    return indented.join(OS.EOL);\n  },\n\n  colorize: function (code, language = \"Solidity\") {\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false, //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n    };\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n        return chromafi(code, options);\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n        return chromafi(code, options);\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign(\n      {},\n      ...Object.entries(variables).map(([variable, value]) =>\n        variable === \"this\" ? { [replacement]: value } : { [variable]: value }\n      )\n    );\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const { controller } = bugger.selectors;\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const { compilationId, id, internal } = source;\n      //stepInto should skip internal sources, but there still might be\n      //one at the end\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = {\n          ...sources[compilationId],\n          [id]: source\n        };\n      }\n      await bugger.stepInto();\n    }\n    await bugger.reset();\n    //flatten sources before returning\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\n\nmodule.exports = DebugUtils;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUint8ArrayLike = exports.bytesCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:wrap:bytes\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst bytesFromStringCases = [bytesFromHexString, bytesFromIntegerString //dynamic loose mode only; make sure this goes after hex string case!\n];\nconst bytesCasesBasic = [...bytesFromStringCases, bytesFromBoxedString, bytesFromUint8ArrayLike, bytesFromCodecBytesValue, bytesFromCodecUdvtValue, bytesFromEncodingTextInput, bytesFromNumber, bytesFromBoxedNumber, bytesFromBigint, bytesFromBN, bytesFromBig, bytesFromOther //dynamic loose mode only, is failure case otherwise. Make sure this goes last!\n];\nexports.bytesCases = [bytesFromTypeValueInput, ...bytesCasesBasic];\n\nfunction* bytesFromHexString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  const trimmed = Utils.removeUnderscoresHex(input); //(but not between individual hex digits)\n\n  if (!Utils.isByteString(trimmed)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage(\"Input\"));\n  }\n\n  const asHex = validateAndPad(dataType, trimmed, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromIntegerString(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (input.trim() === \"\") {\n    //bigint accepts this but we shouldn't\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage(\"Input\"));\n  }\n\n  const trimmed = Utils.removeUnderscoresNumeric(input);\n  let asBigInt;\n\n  try {\n    //we'll use BigInt to parse integer strings, as it's pretty good at it.\n    //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.\n    asBigInt = BigInt(trimmed);\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input string was not a byte string or integer string\");\n  }\n\n  if (asBigInt < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(asBigInt);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  } //defer to primitive string cases\n\n\n  return yield* dispatch_1.wrapWithCases(dataType, input.valueOf(), wrapOptions, bytesFromStringCases);\n}\n\nfunction* bytesFromUint8ArrayLike(dataType, input, wrapOptions) {\n  if (!Utils.isUint8ArrayLike(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n  } //the next series of checks is delegated to a helper fn\n\n\n  validateUint8ArrayLike(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n\n  let asHex = Conversion.toHexString(new Uint8Array(input)); //I am surprised TS accepts this!\n\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromEncodingTextInput(dataType, input, wrapOptions) {\n  if (!Utils.isEncodingTextInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a in encoding/text form\");\n  }\n\n  if (input.encoding !== \"utf8\") {\n    //(the only allowed encoding :P )\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Unknown or unsupported text encoding ${input.encoding}`);\n  }\n\n  let asHex;\n\n  try {\n    asHex = Conversion.toHexString(Conversion.stringToBytes(input.text));\n  } catch (_a) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);\n  }\n\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromCodecBytesValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"bytes\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  if (!wrapOptions.loose && !(input.type.kind === \"dynamic\" && dataType.kind === \"dynamic\") && !(input.type.kind === \"static\" && dataType.kind === \"static\" && input.type.length === dataType.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  let asHex = input.value.asHex;\n  asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromCodecUdvtValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"userDefinedValueType\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  return yield* bytesFromCodecBytesValue(dataType, input.value, wrapOptions);\n}\n\nfunction* bytesFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (!input.type.match(/^byte(s\\d*)?$/)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  }\n\n  debug(\"input.type: %s\", input.type); //now: determine the specified length; we use \"null\" for dynamic\n  //note that \"byte\" is allowed, with a length of 1\n\n  let length = null;\n  let match = input.type.match(/^bytes(\\d+)$/);\n\n  if (match) {\n    length = Number(match[1]); //static case with specified number\n  } else if (input.type === \"byte\") {\n    //\"byte\" case; set length to 1\n    length = 1;\n  } //otherwise, it's dynamic, so leave it at the default of null\n\n\n  debug(\"length: %o\", length); //check: does the specified length match the data type length?\n\n  if (!(length === null && dataType.kind === \"dynamic\") && !(dataType.kind === \"static\" && length === dataType.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n\n\n  return yield* dispatch_1.wrapWithCases(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), bytesCasesBasic);\n}\n\nfunction* bytesFromNumber(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (typeof input !== \"number\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a number\");\n  }\n\n  if (!Number.isInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n\n  if (!Number.isSafeInteger(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);\n  }\n\n  if (input < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromBoxedNumber(dataType, input, wrapOptions) {\n  //skipping the wrapOptions.loose check, as that'll get checked\n  //in bytesFromNumber\n  if (!Utils.isBoxedNumber(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed number\");\n  } //unbox and try again\n\n\n  return yield* bytesFromNumber(dataType, input.valueOf(), wrapOptions);\n}\n\nfunction* bytesFromBigint(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (typeof input !== \"bigint\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a bigint\");\n  }\n\n  if (input < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromBN(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (!bn_js_1.default.isBN(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a BN\");\n  }\n\n  if (input.isNeg()) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromBig(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);\n  }\n\n  if (!Conversion.isBig(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Big\");\n  }\n\n  if (Conversion.countDecimalPlaces(input) !== 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);\n  }\n\n  if (input.lt(0)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(input);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction* bytesFromOther(dataType, input, wrapOptions) {\n  if (!wrapOptions.loose || dataType.kind === \"static\") {\n    //outside of the dynamic-loose case, this is just a failure case\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, or wrapped bytestring\");\n  }\n\n  const request = {\n    kind: \"integer\",\n    input\n  };\n  const response = yield request;\n\n  if (response.kind !== \"integer\") {\n    throw new errors_1.BadResponseTypeError(request, response);\n  }\n\n  if (response.value === null) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || \"Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, integer input, or wrapped bytestring\");\n  }\n\n  if (response.value < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);\n  }\n\n  let asHex = Conversion.toHexString(response.value);\n  asHex = adjustZeroNumericInput(asHex); //because we're in dynamic case, we can skip validateAndPad\n\n  return {\n    //TS is complaining again\n    type: dataType,\n    kind: \"value\",\n    value: {\n      asHex\n    }\n  };\n}\n\nfunction validateUint8ArrayLike(input, dataType, //for error information\nname //for error information\n) {\n  //this function doesn't return anything, it just throws errors if something\n  //goes wrong\n  if (input instanceof Uint8Array) {\n    return; //honest Uint8Arrays don't need checking\n  }\n\n  if (!Number.isSafeInteger(input.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, \"Input is byte-array-like, but its length is not a safe integer\");\n  }\n\n  if (input.length < 0) {\n    throw new errors_1.TypeMismatchError(dataType, input, name, 5, \"Input is byte-array-like, but its length is negative\");\n  } //check: is it actually like a Uint8Array?\n\n\n  for (let index = 0; index < input.length; index++) {\n    if (typeof input[index] !== \"number\" || input[index] < 0 || input[index] >= 256 || !Number.isInteger(input[index])) {\n      throw new errors_1.TypeMismatchError(dataType, input, name, 5, `Input is byte-array-like, but byte ${index} is not a 1-byte value (number from 0 to 255)`);\n    }\n  } //otherwise, we didn't throw any errors, so return\n\n}\n\nexports.validateUint8ArrayLike = validateUint8ArrayLike;\n\nfunction validateAndPad(dataType, asHex, input, //for errors\nname //for errors\n) {\n  asHex = asHex.toLowerCase(); //if static, validate and pad\n\n  if (dataType.kind === \"static\") {\n    if ((asHex.length - 2) / 2 > dataType.length) {\n      throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.overlongMessage(dataType.length, (asHex.length - 2) / 2));\n    } else {\n      asHex = asHex.padEnd(dataType.length * 2 + 2, \"00\");\n    }\n  }\n\n  return asHex;\n} //special case for ethers compatibility; represents 0 as 0x00 rather than 0x.\n//only for numeric input in loose mode, in dynamic case, for compatibility; not\n//for ordinary hex input, where the two are distinct!\n\n\nfunction adjustZeroNumericInput(asHex) {\n  return asHex === \"0x\" ? \"0x00\" : asHex;\n}","map":{"version":3,"mappings":"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","names":["debug","debug_1","bytesFromStringCases","bytesFromHexString","bytesFromIntegerString","bytesCasesBasic","bytesFromBoxedString","bytesFromUint8ArrayLike","bytesFromCodecBytesValue","bytesFromCodecUdvtValue","bytesFromEncodingTextInput","bytesFromNumber","bytesFromBoxedNumber","bytesFromBigint","bytesFromBN","bytesFromBig","bytesFromOther","exports","bytesFromTypeValueInput","dataType","input","wrapOptions","errors_1","name","trimmed","Utils","removeUnderscoresHex","isByteString","Messages","notABytestringMessage","asHex","validateAndPad","type","kind","value","loose","looseModeOnlyMessage","trim","removeUnderscoresNumeric","asBigInt","BigInt","negativeBytesMessage","Conversion","toHexString","adjustZeroNumericInput","isBoxedString","dispatch_1","valueOf","isUint8ArrayLike","validateUint8ArrayLike","Uint8Array","isEncodingTextInput","encoding","stringToBytes","text","invalidUtf16Message","isWrappedResult","typeClass","wrappedTypeMessage","errorResultMessage","length","isTypeValueInput","match","specifiedTypeMessage","Number","Object","isInteger","nonIntegerMessage","isSafeInteger","nonSafeMessage","isBoxedNumber","bn_js_1","isBN","isNeg","isBig","countDecimalPlaces","lt","request","response","partiallyRecognized","reason","index","toLowerCase","overlongMessage","padEnd"],"sourceRoot":"","sources":["../../../lib/wrap/bytes.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
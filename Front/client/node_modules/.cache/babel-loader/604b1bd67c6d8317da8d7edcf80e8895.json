{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:core\");\n\nconst Ast = __importStar(require(\"./ast\"));\n\nconst AbiData = __importStar(require(\"./abi-data\"));\n\nconst Topic = __importStar(require(\"./topic\"));\n\nconst Evm = __importStar(require(\"./evm\"));\n\nconst Contexts = __importStar(require(\"./contexts\"));\n\nconst abify_1 = require(\"./abify\");\n\nconst Conversion = __importStar(require(\"./conversion\"));\n\nconst errors_1 = require(\"./errors\");\n\nconst read_1 = __importDefault(require(\"./read\"));\n\nconst decode_1 = __importDefault(require(\"./decode\"));\n\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\n/**\n * @Category Decoding\n */\n\n\nfunction* decodeVariable(definition, pointer, info, compilationId) {\n  let compiler = info.currentContext.compiler;\n  let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n  return yield* decode_1.default(dataType, pointer, info); //no need to pass an offset\n}\n\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\n\nfunction* decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n  const context = info.currentContext;\n\n  if (context === null) {\n    //if we don't know the contract ID, we can't decode\n    if (isConstructor) {\n      return {\n        kind: \"create\",\n        decodingMode: \"full\",\n        bytecode: Conversion.toHexString(info.state.calldata),\n        interpretations: {}\n      };\n    } else {\n      return {\n        kind: \"unknown\",\n        decodingMode: \"full\",\n        data: Conversion.toHexString(info.state.calldata),\n        interpretations: {}\n      };\n    }\n  }\n\n  const contextHash = context.context;\n  const contractType = Contexts.Import.contextToType(context);\n  isConstructor = context.isConstructor;\n  const allocations = info.allocations.calldata;\n  let allocation;\n  let selector; //first: is this a creation call?\n\n  if (isConstructor) {\n    allocation = (allocations.constructorAllocations[contextHash] || {\n      input: undefined\n    }).input;\n  } else {\n    //skipping any error-handling on this read, as a calldata read can't throw anyway\n    let rawSelector = yield* read_1.default({\n      location: \"calldata\",\n      start: 0,\n      length: Evm.Utils.SELECTOR_SIZE\n    }, info.state);\n    selector = Conversion.toHexString(rawSelector);\n    allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {\n      input: undefined\n    }).input;\n  }\n\n  if (allocation === undefined) {\n    let abiEntry = null;\n\n    if (info.state.calldata.length === 0) {\n      //to hell with reads, let's just be direct\n      abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n    } else {\n      abiEntry = context.fallbackAbi.fallback;\n    }\n\n    return {\n      kind: \"message\",\n      class: contractType,\n      abi: abiEntry,\n      data: Conversion.toHexString(info.state.calldata),\n      decodingMode: \"full\",\n      interpretations: {}\n    };\n  }\n\n  let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n\n  debug(\"calldata decoding mode: %s\", decodingMode); //you can't map with a generator, so we have to do this map manually\n\n  let decodedArguments = [];\n\n  for (const argumentAllocation of allocation.arguments) {\n    let value;\n    let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n\n    try {\n      value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n        abiPointerBase: allocation.offset,\n        allowRetry: decodingMode === \"full\"\n      });\n    } catch (error) {\n      if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n        debug(\"problem! retrying as ABI\");\n        debug(\"error: %O\", error); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n        //1. mark that we're switching to ABI mode;\n\n        decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n        decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n          value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n        })); //3. retry this particular decode in ABI mode.\n        //(no try/catch on this one because we can't actually handle errors here!\n        //not that they should be occurring)\n\n        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n        argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.offset\n        }); //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n        //so we don't need to do anything special there.\n      } else {\n        //we shouldn't be getting other exceptions, but if we do, we don't know\n        //how to handle them, so uhhhh just rethrow I guess??\n        throw error;\n      }\n    }\n\n    const name = argumentAllocation.name;\n    decodedArguments.push(name //deliberate general falsiness test\n    ? {\n      name,\n      value\n    } : {\n      value\n    });\n  }\n\n  if (isConstructor) {\n    return {\n      kind: \"constructor\",\n      class: contractType,\n      arguments: decodedArguments,\n      abi: allocation.abi,\n      bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n      decodingMode,\n      interpretations: {}\n    };\n  } else {\n    return {\n      kind: \"function\",\n      class: contractType,\n      abi: allocation.abi,\n      arguments: decodedArguments,\n      selector,\n      decodingMode,\n      interpretations: {}\n    };\n  }\n}\n\nexports.decodeCalldata = decodeCalldata;\n/**\n * @Category Decoding\n */\n\nfunction* decodeEvent(info, address) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const allocations = info.allocations.event;\n  const extras = options.extras || \"off\";\n  let rawSelector;\n  let selector;\n  let contractAllocations; //for non-anonymous events\n\n  let libraryAllocations; //similar\n\n  let contractAnonymousAllocations;\n  let libraryAnonymousAllocations;\n  const topicsCount = info.state.eventtopics.length; //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n\n  if (allocations[topicsCount]) {\n    if (topicsCount > 0) {\n      rawSelector = yield* read_1.default({\n        location: \"eventtopic\",\n        topic: 0\n      }, info.state);\n      selector = Conversion.toHexString(rawSelector);\n\n      if (allocations[topicsCount].bySelector[selector]) {\n        ({\n          contract: contractAllocations,\n          library: libraryAllocations\n        } = allocations[topicsCount].bySelector[selector]);\n      } else {\n        debug(\"no allocations for that selector!\");\n        contractAllocations = {};\n        libraryAllocations = {};\n      }\n    } else {\n      //if we don't have a selector, it means we don't have any non-anonymous events\n      contractAllocations = {};\n      libraryAllocations = {};\n    } //now: let's get our allocations for anonymous events\n\n\n    ({\n      contract: contractAnonymousAllocations,\n      library: libraryAnonymousAllocations\n    } = allocations[topicsCount].anonymous);\n  } else {\n    //if there's not even an allocation for the topics count, we can't\n    //decode; we could do this the honest way of setting all four allocation\n    //objects to {}, but let's just short circuit\n    debug(\"no allocations for that topic count!\");\n    return [];\n  }\n\n  let contractContext;\n\n  if (address !== null) {\n    //now: what contract are we (probably) dealing with? let's get its code to find out\n    const codeBytes = yield {\n      type: \"code\",\n      address\n    };\n    const codeAsHex = Conversion.toHexString(codeBytes);\n    contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);\n  } else {\n    contractContext = info.currentContext;\n  }\n\n  let possibleContractAllocations; //excludes anonymous events\n\n  let possibleContractAnonymousAllocations;\n  let possibleExtraAllocations; //excludes anonymous events\n\n  let possibleExtraAnonymousAllocations;\n  const emittingContextHash = (contractContext || {\n    context: undefined\n  }).context;\n\n  if (emittingContextHash) {\n    //if we found the contract, maybe it's from that contract\n    const contractAllocation = contractAllocations[emittingContextHash];\n    const contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];\n    possibleContractAllocations = contractAllocation || [];\n    possibleContractAnonymousAllocations = contractAnonymousAllocation || []; //also, we need to set up the extras (everything that's from a\n    //non-library contract but *not* this one)\n\n    possibleExtraAllocations = [].concat(...Object.entries(contractAllocations).filter(_ref => {\n      let [key, _] = _ref;\n      return key !== emittingContextHash;\n    }).map(_ref2 => {\n      let [_, value] = _ref2;\n      return value;\n    }));\n    possibleExtraAnonymousAllocations = [].concat(...Object.entries(contractAnonymousAllocations).filter(_ref3 => {\n      let [key, _] = _ref3;\n      return key !== emittingContextHash;\n    }).map(_ref4 => {\n      let [_, value] = _ref4;\n      return value;\n    }));\n  } else {\n    //if we couldn't determine the contract, well, we have to assume it's from a library\n    debug(\"couldn't find context\");\n    possibleContractAllocations = [];\n    possibleContractAnonymousAllocations = []; //or it's an extra, which could be any of the contracts\n\n    possibleExtraAllocations = [].concat(...Object.values(contractAllocations));\n    possibleExtraAnonymousAllocations = [].concat(...Object.values(contractAnonymousAllocations));\n  } //now we get all the library allocations!\n\n\n  const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));\n  const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations)); //now we put it all together!\n\n  const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n  const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n  const possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations); //...and also there's the extras\n\n  const possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);\n  const possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null], //HACK: add sentinel value before the extras\n  possibleExtraAllocationsTotal); //whew!\n\n  let decodings = [];\n\n  allocationAttempts: for (const allocation of possibleAllocationsTotal) {\n    debug(\"trying allocation: %O\", allocation); //first: check for our sentinel value for extras (yeah, kind of HACKy)\n\n    if (allocation === null) {\n      switch (extras) {\n        case \"on\":\n          continue allocationAttempts;\n        //ignore the sentinel and continue\n\n        case \"off\":\n          break allocationAttempts;\n        //don't include extras; stop here\n\n        case \"necessary\":\n          //stop on the sentinel and exclude extras *unless* there are no decodings yet\n          if (decodings.length > 0) {\n            break allocationAttempts;\n          } else {\n            continue allocationAttempts;\n          }\n\n      }\n    } //second: do a name check so we can skip decoding if name is wrong\n    //(this will likely be a more detailed check in the future)\n\n\n    if (options.name !== undefined && allocation.abi.name !== options.name) {\n      continue;\n    } //now: the main part!\n\n\n    let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n\n    const contextHash = allocation.contextHash;\n    const attemptContext = info.contexts[contextHash];\n    const emittingContractType = Contexts.Import.contextToType(attemptContext);\n    const contractType = allocation.definedIn; //you can't map with a generator, so we have to do this map manually\n\n    let decodedArguments = [];\n\n    for (const argumentAllocation of allocation.arguments) {\n      let value; //if in full mode, use the allocation's listed data type.\n      //if in ABI mode, abify it before use.\n\n      let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n\n      try {\n        value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n          strictAbiMode: true,\n          allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n        });\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n          //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n          })); //3. retry this particular decode in ABI mode.\n\n          try {\n            value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n            argumentAllocation.pointer, info, {\n              strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n              //retries no longer allowed, not that this has an effect\n\n            });\n          } catch (_) {\n            //if an error occurred on the retry, this isn't a valid decoding!\n            debug(\"rejected due to exception on retry\");\n            continue allocationAttempts;\n          } //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n          //so we don't need to do anything special there.\n\n        } else {\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", error);\n          continue allocationAttempts;\n        }\n      }\n\n      const name = argumentAllocation.name;\n      const indexed = argumentAllocation.pointer.location === \"eventtopic\";\n      decodedArguments.push(name //deliberate general falsiness test\n      ? {\n        name,\n        indexed,\n        value\n      } : {\n        indexed,\n        value\n      });\n    }\n\n    if (!options.disableChecks) {\n      //OK, so, having decoded the result, the question is: does it reencode to the original?\n      //NOTE: we skip this check if disableChecks is passed! (it shouldn't be passed :P )\n      //first, we have to filter out the indexed arguments, and also get rid of the name information\n      const nonIndexedValues = decodedArguments.filter(argument => !argument.indexed).map(argument => argument.value); //now, we can encode!\n\n      const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n      const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n      //are they equal?\n\n      if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n        //if not, this allocation doesn't work\n        debug(\"rejected due to [non-indexed] mismatch\");\n        continue;\n      }\n    } //one last check -- let's check that the indexed arguments match up, too\n    //(we won't skip this even if disableChecks was passed)\n\n\n    const indexedValues = decodedArguments.filter(argument => argument.indexed).map(argument => argument.value);\n    const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n    const encodedTopics = info.state.eventtopics; //now: do *these* match?\n\n    const selectorAdjustment = allocation.anonymous ? 0 : 1;\n\n    for (let i = 0; i < reEncodedTopics.length; i++) {\n      if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n        debug(\"rejected due to indexed mismatch\");\n        continue allocationAttempts;\n      }\n    } //if we've made it here, the allocation works!  hooray!\n\n\n    debug(\"allocation accepted!\");\n    let decoding;\n\n    if (allocation.abi.anonymous) {\n      decoding = {\n        kind: \"anonymous\",\n        definedIn: contractType,\n        class: emittingContractType,\n        abi: allocation.abi,\n        arguments: decodedArguments,\n        decodingMode,\n        interpretations: {}\n      };\n    } else {\n      decoding = {\n        kind: \"event\",\n        definedIn: contractType,\n        class: emittingContractType,\n        abi: allocation.abi,\n        arguments: decodedArguments,\n        selector,\n        decodingMode,\n        interpretations: {}\n      };\n    }\n\n    decodings.push(decoding); //if we've made this far (so this allocation works), and we were passed an\n    //ID, and it matches this ID, bail out & return this as the *only* decoding\n\n    if (options.id && allocation.id === options.id) {\n      return [decoding];\n    }\n  }\n\n  return decodings;\n}\n\nexports.decodeEvent = decodeEvent;\nconst errorSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({\n  type: \"string\",\n  value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst panicSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({\n  type: \"string\",\n  value: \"Panic(uint256)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst defaultRevertAllocations = [{\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: errorSelector,\n  abi: {\n    name: \"Error\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"string\",\n      internalType: \"string\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: errorSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"string\",\n      typeHint: \"string\"\n    }\n  }]\n}, {\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: panicSelector,\n  abi: {\n    name: \"Panic\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"uint256\",\n      internalType: \"uint256\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: panicSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"uint\",\n      bits: Evm.Utils.WORD_SIZE * 8,\n      typeHint: \"uint256\"\n    }\n  }]\n}];\nconst defaultEmptyAllocations = [{\n  kind: \"failure\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}, {\n  kind: \"selfdestruct\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode\n * Moreover, within \"revert\", builtin ones are put above custom ones\n * @Category Decoding\n */\n\nfunction* decodeReturndata(info, successAllocation, //null here must be explicit\nstatus, //you can pass this to indicate that you know the status,\nid //useful when status = false\n) {\n  let possibleAllocations;\n  const selector = Conversion.toHexString(info.state.returndata.slice(0, 4));\n  const contextHash = (info.currentContext || {\n    context: \"\"\n  }).context; //HACK: \"\" is used to represent no context\n\n  const customRevertAllocations = ((info.allocations.returndata || {\n    [contextHash]: {}\n  })[contextHash] || {\n    [selector]: []\n  })[selector] || [];\n\n  if (successAllocation === null) {\n    possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n  } else {\n    switch (successAllocation.kind) {\n      case \"return\":\n        possibleAllocations = [successAllocation, ...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n        break;\n\n      case \"bytecode\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations, successAllocation];\n        break;\n\n      case \"returnmessage\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, successAllocation, ...defaultEmptyAllocations];\n        break;\n      //Other cases shouldn't happen so I'm leaving them to cause errors!\n    }\n  }\n\n  let decodings = [];\n\n  allocationAttempts: for (const allocation of possibleAllocations) {\n    debug(\"trying allocation: %O\", allocation); //before we attempt to use this allocation, we check: does the selector match?\n\n    let encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n\n    const encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n\n    if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n      continue;\n    }\n\n    encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n    //also we check, does the status match?\n\n    if (status !== undefined) {\n      const successKinds = [\"return\", \"selfdestruct\", \"bytecode\", \"returnmessage\"];\n      const failKinds = [\"failure\", \"revert\"];\n\n      if (status) {\n        if (!successKinds.includes(allocation.kind)) {\n          continue;\n        }\n      } else {\n        if (!failKinds.includes(allocation.kind)) {\n          continue;\n        }\n      }\n    }\n\n    if (allocation.kind === \"bytecode\") {\n      //bytecode is special and can't really be integrated with the other cases.\n      //so it gets its own function.\n      const decoding = yield* decodeBytecode(info);\n\n      if (decoding) {\n        decodings.push(decoding);\n      }\n\n      continue;\n    }\n\n    if (allocation.kind === \"returnmessage\") {\n      //this kind is also special, though thankfully it's easier\n      const decoding = {\n        kind: \"returnmessage\",\n        status: true,\n        data: Conversion.toHexString(info.state.returndata),\n        decodingMode: allocation.allocationMode,\n        interpretations: {}\n      };\n      decodings.push(decoding);\n      continue;\n    }\n\n    let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n    //you can't map with a generator, so we have to do this map manually\n\n    let decodedArguments = [];\n\n    for (const argumentAllocation of allocation.arguments) {\n      let value; //if in full mode, use the allocation's listed data type.\n      //if in ABI mode, abify it before use.\n\n      let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes); //now, let's decode!\n\n      try {\n        value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.selector.length,\n          strictAbiMode: true,\n          allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n        });\n        debug(\"value on first try: %O\", value);\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n          debug(\"retry!\"); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n          })); //3. retry this particular decode in ABI mode.\n\n          try {\n            value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n            argumentAllocation.pointer, info, {\n              abiPointerBase: allocation.selector.length,\n              strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n              //retries no longer allowed, not that this has an effect\n\n            });\n            debug(\"value on retry: %O\", value);\n          } catch (_) {\n            //if an error occurred on the retry, this isn't a valid decoding!\n            debug(\"rejected due to exception on retry\");\n            continue allocationAttempts;\n          } //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n          //so we don't need to do anything special there.\n\n        } else {\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", error);\n          continue allocationAttempts;\n        }\n      }\n\n      const name = argumentAllocation.name;\n      decodedArguments.push(name //deliberate general falsiness test\n      ? {\n        name,\n        value\n      } : {\n        value\n      });\n    } //OK, so, having decoded the result, the question is: does it reencode to the original?\n    //first, we have to filter out the indexed arguments, and also get rid of the name information\n\n\n    debug(\"decodedArguments: %O\", decodedArguments);\n    const decodedArgumentValues = decodedArguments.map(argument => argument.value);\n    const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi); //are they equal? note the selector has been stripped off encodedData!\n\n    if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n      //if not, this allocation doesn't work\n      debug(\"rejected due to mismatch\");\n      continue;\n    } //if we've made it here, the allocation works!  hooray!\n\n\n    debug(\"allocation accepted!\");\n    let decoding;\n\n    switch (allocation.kind) {\n      case \"return\":\n        decoding = {\n          kind: \"return\",\n          status: true,\n          arguments: decodedArguments,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n\n      case \"revert\":\n        decoding = {\n          kind: \"revert\",\n          abi: allocation.abi,\n          definedIn: allocation.definedIn,\n          status: false,\n          arguments: decodedArguments,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n\n      case \"selfdestruct\":\n        decoding = {\n          kind: \"selfdestruct\",\n          status: true,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n\n      case \"failure\":\n        decoding = {\n          kind: \"failure\",\n          status: false,\n          decodingMode,\n          interpretations: {}\n        };\n        break;\n    }\n\n    decodings.push(decoding); //if we've made this far (so this allocation works), and we were passed an\n    //ID, and it matches this ID, bail out & return this as the *only* decoding\n\n    if (id && allocation.kind === \"revert\" && allocation.id === id) {\n      return [decoding];\n    }\n  }\n\n  return decodings;\n}\n\nexports.decodeReturndata = decodeReturndata; //note: requires the bytecode to be in returndata, not code\n\nfunction* decodeBytecode(info) {\n  let decodingMode = \"full\"; //as always, degrade as necessary\n\n  const bytecode = Conversion.toHexString(info.state.returndata);\n  const context = Contexts.Utils.findContext(info.contexts, bytecode);\n\n  if (!context) {\n    return {\n      kind: \"unknownbytecode\",\n      status: true,\n      decodingMode: \"full\",\n      bytecode,\n      interpretations: {}\n    };\n  }\n\n  const contractType = Contexts.Import.contextToType(context); //now: ignore original allocation (which we didn't even pass :) )\n  //and lookup allocation by context\n\n  const allocation = info.allocations.calldata.constructorAllocations[context.context].output;\n  debug(\"bytecode allocation: %O\", allocation); //now: add immutables if applicable\n\n  let immutables;\n\n  if (allocation.immutables) {\n    immutables = []; //NOTE: if we're in here, we can assume decodingMode === \"full\"\n\n    for (const variable of allocation.immutables) {\n      const dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n\n      let value;\n\n      try {\n        value = yield* decode_1.default(dataType, variable.pointer, info, {\n          allowRetry: true,\n          strictAbiMode: true,\n          paddingMode: \"defaultOrZero\"\n        });\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry) {\n          //we \"retry\" by... not bothering with immutables :P\n          //(but we do set the mode to ABI)\n          decodingMode = \"abi\";\n          immutables = undefined;\n          break;\n        } else {\n          //otherwise, this isn't a valid decoding I guess\n          return null;\n        }\n      }\n\n      immutables.push({\n        name: variable.name,\n        class: variable.definedIn,\n        value\n      });\n    }\n  }\n\n  let decoding = {\n    kind: \"bytecode\",\n    status: true,\n    decodingMode,\n    bytecode,\n    immutables,\n    class: contractType,\n    interpretations: {}\n  }; //finally: add address if applicable\n\n  if (allocation.delegatecallGuard) {\n    decoding.address = web3_utils_1.default.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n    );\n  }\n\n  return decoding;\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\n\n\nfunction decodeRevert(returndata) {\n  //coercing because TS doesn't know it'll finish in one go\n  return decodeReturndata({\n    allocations: {},\n    state: {\n      storage: {},\n      returndata\n    }\n  }, null, false).next().value;\n}\n\nexports.decodeRevert = decodeRevert;","map":{"version":3,"mappings":"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","names":["debug","debug_1","decodeVariable","definition","pointer","info","compilationId","compiler","currentContext","dataType","Ast","Import","definitionToType","decode_1","exports","decodeCalldata","isConstructor","context","kind","decodingMode","bytecode","Conversion","toHexString","state","calldata","interpretations","data","contextHash","contractType","Contexts","contextToType","allocations","allocation","selector","constructorAllocations","input","undefined","rawSelector","read_1","location","start","length","Evm","Utils","SELECTOR_SIZE","functionAllocations","abiEntry","fallbackAbi","receive","fallback","class","abi","allocationMode","decodedArguments","argumentAllocation","arguments","value","type","abify_1","userDefinedTypes","abiPointerBase","offset","allowRetry","error","errors_1","map","argumentDecoding","Object","name","push","slice","decodeEvent","address","options","event","extras","contractAllocations","libraryAllocations","contractAnonymousAllocations","libraryAnonymousAllocations","topicsCount","eventtopics","topic","bySelector","contract","library","anonymous","contractContext","codeBytes","codeAsHex","findContext","contexts","possibleContractAllocations","possibleContractAnonymousAllocations","possibleExtraAllocations","possibleExtraAnonymousAllocations","emittingContextHash","contractAllocation","contractAnonymousAllocation","concat","entries","filter","key","_","values","possibleLibraryAllocations","possibleLibraryAnonymousAllocations","possibleAllocations","possibleAnonymousAllocations","possibleAllocationsTotalMinusExtras","possibleExtraAllocationsTotal","possibleAllocationsTotal","decodings","allocationAttempts","attemptContext","emittingContractType","definedIn","strictAbiMode","indexed","disableChecks","nonIndexedValues","argument","reEncodedData","AbiData","Encode","encodeTupleAbi","encodedData","eventdata","equalData","indexedValues","reEncodedTopics","Topic","encodeTopic","encodedTopics","selectorAdjustment","i","decoding","id","errorSelector","toBytes","web3_utils_1","soliditySha3","subarray","panicSelector","defaultRevertAllocations","inputs","internalType","WORD_SIZE","typeClass","typeHint","bits","defaultEmptyAllocations","Uint8Array","decodeReturndata","successAllocation","status","returndata","customRevertAllocations","encodedPrefix","successKinds","failKinds","includes","decodeBytecode","decodedArgumentValues","output","immutables","variable","paddingMode","delegatecallGuard","toChecksumAddress","ADDRESS_SIZE","decodeRevert","storage","next"],"sourceRoot":"","sources":["../../lib/core.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
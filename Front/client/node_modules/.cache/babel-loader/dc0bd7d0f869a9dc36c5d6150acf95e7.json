{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeAbi(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\") {\n    //I don't want tuples to be considered a reference type, but it makes sense\n    //to group them for this purpose\n    let dynamic;\n\n    try {\n      dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n    } catch (error) {\n      return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n    }\n\n    if (dynamic) {\n      return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n    } else {\n      return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n    }\n  } else {\n    debug(\"pointer %o\", pointer);\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n  }\n}\n\nexports.decodeAbi = decodeAbi;\n\nfunction* decodeAbiReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let {\n    strictAbiMode: strict,\n    abiPointerBase: base,\n    lengthOverride\n  } = options;\n  base = base || 0; //in case base was undefined\n\n  const {\n    allocations: {\n      abi: allocations\n    },\n    state\n  } = info;\n  debug(\"pointer %o\", pointer); //this variable holds the location we should look to *next*\n  //stack pointers point to calldata; other pointers point to same location\n\n  const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n\n  if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n    //length overrides are only applicable when you're decoding a pointer\n    //from the stack!  otherwise they must be ignored!\n    lengthOverride = undefined;\n  }\n\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  let rawValueAsBN = Conversion.toBN(rawValue);\n  debug(\"rawValue: %O\", rawValue);\n  debug(\"rawValueAsBN: %O\", rawValueAsBN);\n  let rawValueAsNumber;\n\n  try {\n    rawValueAsNumber = rawValueAsBN.toNumber();\n  } catch (_a) {\n    let error = {\n      kind: \"OverlargePointersNotImplementedError\",\n      pointerAsBN: rawValueAsBN\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      //again with the TS failures...\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  let startPosition = rawValueAsNumber + base;\n  debug(\"startPosition %d\", startPosition);\n  let dynamic;\n  let size;\n\n  try {\n    ({\n      dynamic,\n      size\n    } = allocate_1.abiSizeInfo(dataType, allocations));\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  if (!dynamic) {\n    //this will only come up when called from stack.ts\n    let staticPointer = {\n      location,\n      start: startPosition,\n      length: size\n    };\n    return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n  }\n\n  let length;\n  let lengthAsBN;\n  let rawLength;\n\n  switch (dataType.typeClass) {\n    case \"bytes\":\n    case \"string\":\n      //initial word contains length (unless an override was given)\n      if (lengthOverride !== undefined) {\n        lengthAsBN = lengthOverride; //note in this case we do *not* increment start position;\n        //if a length override is given, that means the given start\n        //position skips over the length word!\n      } else {\n        try {\n          rawLength = yield* read_1.default({\n            location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error, strict);\n        }\n\n        lengthAsBN = Conversion.toBN(rawLength);\n        startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n        //so it'll be set up to read the data\n      }\n\n      if (strict && lengthAsBN.gtn(state[location].length)) {\n        //you may notice that the comparison is a bit crude; that's OK, this is\n        //just to prevent huge numbers from DOSing us, other errors will still\n        //be caught regardless\n        throw new errors_1.StopDecodingError({\n          kind: \"OverlongArrayOrStringStrictModeError\",\n          lengthAsBN,\n          dataLength: state[location].length\n        });\n      }\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_b) {\n        //note: if we're in this situation, we can assume we're not in strict mode,\n        //as the strict case was handled above\n        return {\n          //again with the TS failures...\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      }\n\n      let childPointer = {\n        location,\n        start: startPosition,\n        length\n      };\n      return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n\n    case \"array\":\n      if (dataType.kind === \"static\") {\n        //static-length array\n        lengthAsBN = dataType.length; //note we don't increment start position; static arrays don't\n        //include a length word!\n      } else if (lengthOverride !== undefined) {\n        debug(\"override: %o\", lengthOverride); //dynamic-length array, but with length override\n\n        lengthAsBN = lengthOverride; //we don't increment start position; if a length override was\n        //given, that means the pointer skipped the length word!\n      } else {\n        //dynamic-length array, read length from data\n        //initial word contains array length\n        try {\n          rawLength = yield* read_1.default({\n            location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error, strict);\n        }\n\n        lengthAsBN = Conversion.toBN(rawLength);\n        startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n        //to next word, as first word was used for length\n      }\n\n      if (strict && lengthAsBN.gtn(state[location].length)) {\n        //you may notice that the comparison is a bit crude; that's OK, this is\n        //just to prevent huge numbers from DOSing us, other errors will still\n        //be caught regardless\n        throw new errors_1.StopDecodingError({\n          kind: \"OverlongArraysAndStringsNotImplementedError\",\n          lengthAsBN,\n          dataLength: state[location].length\n        });\n      }\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_c) {\n        //again, if we get here, we can assume we're not in strict mode\n        return {\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      } //note: I've written this fairly generically, but it is worth noting that\n      //since this array is of dynamic type, we know that if it's static length\n      //then size must be EVM.WORD_SIZE\n\n\n      let baseSize;\n\n      try {\n        baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n      } catch (error) {\n        return errors_1.handleDecodingError(dataType, error, strict);\n      }\n\n      let decodedChildren = [];\n\n      for (let index = 0; index < length; index++) {\n        decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n          location,\n          start: startPosition + index * baseSize,\n          length: baseSize\n        }, info, Object.assign(Object.assign({}, options), {\n          abiPointerBase: startPosition\n        }))); //pointer base is always start of list, never the length\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedChildren\n      };\n\n    case \"struct\":\n      return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n\n    case \"tuple\":\n      return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n  }\n}\n\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\n\nfunction* decodeAbiReferenceStatic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  debug(\"static\");\n  debug(\"pointer %o\", pointer);\n  const location = pointer.location;\n\n  switch (dataType.typeClass) {\n    case \"array\":\n      //we're in the static case, so we know the array must be statically sized\n      const lengthAsBN = dataType.length;\n      let length;\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_a) {\n        //note: since this is the static case, we don't bother including the stronger\n        //strict-mode guard against getting DOSed by large array sizes, since in this\n        //case we're not reading the size from the input; if there's a huge static size\n        //array, well, we'll just have to deal with it\n        let error = {\n          kind: \"OverlongArraysAndStringsNotImplementedError\",\n          lengthAsBN\n        };\n\n        if (options.strictAbiMode) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      let baseSize;\n\n      try {\n        baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n      } catch (error) {\n        return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n      }\n\n      let decodedChildren = [];\n\n      for (let index = 0; index < length; index++) {\n        decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n          location,\n          start: pointer.start + index * baseSize,\n          length: baseSize\n        }, info, options));\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedChildren\n      };\n\n    case \"struct\":\n      return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n\n    case \"tuple\":\n      return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n  }\n}\n\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic; //note that this function takes the start position as a *number*; it does not take a pointer\n\nfunction* decodeAbiStructByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const {\n    allocations: {\n      abi: allocations\n    }\n  } = info;\n  const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n\n  const typeId = dataType.id;\n  const structAllocation = allocations[typeId];\n\n  if (!structAllocation) {\n    let error = {\n      kind: \"UserDefinedTypeNotFoundError\",\n      type: dataType\n    };\n\n    if (options.strictAbiMode || options.allowRetry) {\n      throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the allocation!\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  let decodedMembers = [];\n\n  for (let index = 0; index < structAllocation.members.length; index++) {\n    const memberAllocation = structAllocation.members[index];\n    const memberPointer = memberAllocation.pointer;\n    const childPointer = {\n      location,\n      start: startPosition + memberPointer.start,\n      length: memberPointer.length\n    };\n    let memberName = memberAllocation.name;\n    let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n    decodedMembers.push({\n      name: memberName,\n      value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n        abiPointerBase: startPosition\n      })) //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n\n    });\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: decodedMembers\n  };\n} //note that this function takes the start position as a *number*; it does not take a pointer\n\n\nfunction* decodeAbiTupleByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n  //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n  //However it may be worth revisiting this in the future if performance turns out to be a problem\n  //(changing this may be pretty hard though)\n  let decodedMembers = [];\n  let position = startPosition;\n\n  for (const {\n    name,\n    type: memberType\n  } of dataType.memberTypes) {\n    const memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n    const childPointer = {\n      location,\n      start: position,\n      length: memberSize\n    };\n    decodedMembers.push({\n      name,\n      value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n        abiPointerBase: startPosition\n      })) //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n\n    });\n    position += memberSize;\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: decodedMembers\n  };\n}","map":{"version":3,"mappings":"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","names":["debug","debug_1","decodeAbi","dataType","pointer","info","options","Format","Types","isReferenceType","typeClass","dynamic","allocate_1","allocations","abi","error","errors_1","strictAbiMode","decodeAbiReferenceByAddress","decodeAbiReferenceStatic","Basic","Decode","decodeBasic","exports","strict","abiPointerBase","base","lengthOverride","state","location","undefined","rawValue","read_1","rawValueAsBN","Conversion","toBN","rawValueAsNumber","toNumber","kind","pointerAsBN","type","startPosition","size","staticPointer","start","length","lengthAsBN","rawLength","Evm","Utils","WORD_SIZE","gtn","dataLength","childPointer","Bytes","decodeBytes","baseSize","baseType","decodedChildren","index","push","Object","value","decodeAbiStructByPosition","decodeAbiTupleByPosition","typeLocation","typeId","id","structAllocation","allowRetry","decodedMembers","members","memberAllocation","memberPointer","memberName","name","memberType","specifyLocation","position","memberTypes","memberSize"],"sourceRoot":"","sources":["../../../../lib/abi-data/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:basic:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Contexts = __importStar(require(\"../../contexts\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nconst allocate_1 = require(\"../allocate\");\n\nfunction* decodeBasic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    state\n  } = info;\n  const {\n    strictAbiMode: strict\n  } = options; //if this is undefined it'll still be falsy so it's OK\n\n  const paddingMode = options.paddingMode || \"default\";\n  let bytes;\n  let rawBytes;\n\n  try {\n    bytes = yield* read_1.default(pointer, state);\n  } catch (error) {\n    debug(\"segfault, pointer %o, state: %O\", pointer, state);\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  rawBytes = bytes;\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer);\n\n  switch (dataType.typeClass) {\n    case \"userDefinedValueType\":\n      {\n        const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n        if (!fullType.underlyingType) {\n          const error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: fullType\n          };\n\n          if (strict || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the underlying type!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        const underlyingResult = yield* decodeBasic(fullType.underlyingType, pointer, info, options);\n\n        switch (underlyingResult.kind //yes this switch is a little unnecessary :P\n        ) {\n          case \"value\":\n            //wrap the value and return\n            return {\n              //no idea why need coercion here\n              type: fullType,\n              kind: \"value\",\n              value: underlyingResult\n            };\n\n          case \"error\":\n            //wrap the error and return an error result!\n            //this is inconsistent with how we handle other container types\n            //(structs, arrays, mappings), where having an error in one element\n            //does not cause an error in the whole thing, but to do that here\n            //would cause problems for the type system :-/\n            //so we'll just be inconsistent\n            return {\n              //TS is being bad again :-/\n              type: fullType,\n              kind: \"error\",\n              error: {\n                kind: \"WrappedError\",\n                error: underlyingResult\n              }\n            };\n        }\n\n        break; //to satisfy TS :P\n      }\n\n    case \"bool\":\n      {\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"BoolPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        bytes = removePadding(bytes, dataType, paddingMode); //note: the use of the BN is a little silly here,\n        //but, kind of stuck with it for now\n\n        const numeric = Conversion.toBN(bytes);\n\n        if (numeric.eqn(0)) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: false\n            }\n          };\n        } else if (numeric.eqn(1)) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n        } else {\n          let error = {\n            kind: \"BoolOutOfRangeError\",\n            rawAsBN: numeric\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n      }\n\n    case \"uint\":\n      //first, check padding (if needed)\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"UintPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN: Conversion.toBN(bytes),\n          rawAsBN: Conversion.toBN(rawBytes)\n        }\n      };\n\n    case \"int\":\n      //first, check padding (if needed)\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"IntPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN: Conversion.toSignedBN(bytes),\n          rawAsBN: Conversion.toSignedBN(rawBytes)\n        }\n      };\n\n    case \"address\":\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"AddressPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asAddress: Evm.Utils.toAddress(bytes),\n          rawAsHex: Conversion.toHexString(rawBytes)\n        }\n      };\n\n    case \"contract\":\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"ContractPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n      const contractValueInfo = yield* decodeContract(bytes, info);\n      return {\n        type: fullType,\n        kind: \"value\",\n        value: contractValueInfo\n      };\n\n    case \"bytes\":\n      //NOTE: we assume this is a *static* bytestring,\n      //because this is decodeBasic! dynamic ones should\n      //go to decodeBytes!\n      let coercedDataType = dataType; //first, check padding (if needed)\n\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"BytesPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: coercedDataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: coercedDataType,\n        kind: \"value\",\n        value: {\n          asHex: Conversion.toHexString(bytes),\n          rawAsHex: Conversion.toHexString(rawBytes)\n        }\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            const error = {\n              kind: \"FunctionExternalNonStackPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n\n          bytes = removePadding(bytes, dataType, paddingMode);\n          const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n          const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: yield* decodeExternalFunction(address, selector, info)\n          };\n\n        case \"internal\":\n          //note: we used to error if we hit this point with strict === true,\n          //since internal function pointers don't go in the ABI, and strict\n          //mode is intended for ABI decoding.  however, there are times when\n          //we want to use strict mode to decode immutables, and immutables can\n          //include internal function pointers.  so now we allow this.  yes,\n          //this is a bit of an abuse of strict mode, which was after all meant\n          //for ABI decoding, but oh well.\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            const error = {\n              kind: \"FunctionInternalPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n\n          bytes = removePadding(bytes, dataType, paddingMode);\n          const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n          const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n          return decodeInternalFunction(dataType, deployedPc, constructorPc, info, strict);\n      }\n\n      break;\n    //to satisfy TypeScript\n\n    case \"enum\":\n      {\n        let numeric = Conversion.toBN(bytes);\n        const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n        if (!fullType.options) {\n          let error = {\n            kind: \"EnumNotFoundDecodingError\",\n            type: fullType,\n            rawAsBN: numeric\n          };\n\n          if (strict || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the enum type!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        } //note: I'm doing the padding checks a little more manually on this one\n        //so that we can have the right type of error\n\n\n        const numOptions = fullType.options.length;\n        const numBytes = Math.ceil(Math.log2(numOptions) / 8);\n        const paddingType = getPaddingType(dataType, paddingMode);\n\n        if (!checkPaddingDirect(bytes, numBytes, paddingType)) {\n          let error = {\n            kind: \"EnumPaddingError\",\n            type: fullType,\n            paddingType,\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        bytes = removePaddingDirect(bytes, numBytes, paddingType);\n        numeric = Conversion.toBN(bytes); //alter numeric!\n\n        if (numeric.ltn(numOptions)) {\n          const name = fullType.options[numeric.toNumber()]; //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n          //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n          //an enum with that many options in the first place, we have bigger problems!\n\n          return {\n            type: fullType,\n            kind: \"value\",\n            value: {\n              name,\n              numericAsBN: numeric\n            }\n          };\n        } else {\n          let error = {\n            kind: \"EnumOutOfRangeError\",\n            type: fullType,\n            rawAsBN: numeric\n          };\n\n          if (strict) {\n            //note:\n            //if the enum is merely out of range rather than out of the ABI range,\n            //we do NOT throw an error here!  instead we simply return an error value,\n            //which we normally avoid doing in strict mode.  (the error will be caught\n            //later at the re-encoding step instead.)  why?  because we might be running\n            //in ABI mode, so we may need to abify this \"value\" rather than just throwing\n            //it out.\n            throw new errors_1.StopDecodingError(error); //note that we do NOT allow a retry here!\n            //if we *can* find the enum type but the value is out of range,\n            //we *know* that it is invalid!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        }\n      }\n\n    case \"fixed\":\n      {\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"FixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n        bytes = removePadding(bytes, dataType, paddingMode);\n        let asBN = Conversion.toSignedBN(bytes);\n        let rawAsBN = Conversion.toSignedBN(rawBytes);\n        let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n        let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBig,\n            rawAsBig\n          }\n        };\n      }\n\n    case \"ufixed\":\n      {\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"UfixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n        bytes = removePadding(bytes, dataType, paddingMode);\n        let asBN = Conversion.toBN(bytes);\n        let rawAsBN = Conversion.toBN(rawBytes);\n        let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n        let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBig,\n            rawAsBig\n          }\n        };\n      }\n  }\n}\n\nexports.decodeBasic = decodeBasic; //NOTE that this function returns a ContractValueInfo, not a ContractResult\n\nfunction* decodeContract(addressBytes, info) {\n  return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;\n}\n\nexports.decodeContract = decodeContract;\n\nfunction* decodeContractAndContext(addressBytes, info) {\n  let address = Evm.Utils.toAddress(addressBytes);\n  let rawAddress = Conversion.toHexString(addressBytes);\n  let codeBytes = yield {\n    type: \"code\",\n    address\n  };\n  let code = Conversion.toHexString(codeBytes);\n  let context = Contexts.Utils.findContext(info.contexts, code);\n\n  if (context !== null) {\n    return {\n      context,\n      contractInfo: {\n        kind: \"known\",\n        address,\n        rawAddress,\n        class: Contexts.Import.contextToType(context)\n      }\n    };\n  } else {\n    return {\n      context,\n      contractInfo: {\n        kind: \"unknown\",\n        address,\n        rawAddress\n      }\n    };\n  }\n} //note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\n\n\nfunction* decodeExternalFunction(addressBytes, selectorBytes, info) {\n  let {\n    contractInfo: contract,\n    context\n  } = yield* decodeContractAndContext(addressBytes, info);\n  let selector = Conversion.toHexString(selectorBytes);\n\n  if (contract.kind === \"unknown\") {\n    return {\n      kind: \"unknown\",\n      contract,\n      selector\n    };\n  }\n\n  let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n\n  if (abiEntry === undefined) {\n    return {\n      kind: \"invalid\",\n      contract,\n      selector\n    };\n  }\n\n  return {\n    kind: \"known\",\n    contract,\n    selector,\n    abi: abiEntry\n  };\n}\n\nexports.decodeExternalFunction = decodeExternalFunction; //this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\n\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info, strict) {\n  const deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n  const constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n  const context = Contexts.Import.contextToType(info.currentContext); //before anything else: do we even have an internal functions table?\n  //if not, we'll just return the info we have without really attemting to decode\n\n  if (!info.internalFunctionsTable) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"unknown\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //also before we continue: is the PC zero? if so let's just return that\n\n\n  if (deployedPc === 0 && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //another check: is only the deployed PC zero?\n\n\n  if (deployedPc === 0 && constructorPc !== 0) {\n    const error = {\n      kind: \"MalformedInternalFunctionError\",\n      context,\n      deployedProgramCounter: 0,\n      constructorProgramCounter: constructorPc\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  } //one last pre-check: is this a deployed-format pointer in a constructor?\n\n\n  if (info.currentContext.isConstructor && constructorPc === 0) {\n    const error = {\n      kind: \"DeployedFunctionInConstructorError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: 0\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  } //otherwise, we get our function\n\n\n  const pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n  const functionEntry = info.internalFunctionsTable[pc];\n\n  if (!functionEntry) {\n    //if it's not zero and there's no entry... error!\n    const error = {\n      kind: \"NoSuchInternalFunctionError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  if (functionEntry.isDesignatedInvalid) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n\n  const name = functionEntry.name;\n  const mutability = functionEntry.mutability;\n  const definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n\n  const id = Evm.Import.makeInternalFunctionId(functionEntry);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"function\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc,\n      name,\n      id,\n      definedIn,\n      mutability\n    }\n  };\n}\n\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = allocate_1.byteLength(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n\n  if (paddingMode === \"permissive\") {\n    switch (dataType.typeClass) {\n      case \"bool\":\n      case \"enum\":\n      case \"function\":\n        //these three types are checked even in permissive mode\n        return checkPaddingDirect(bytes, length, paddingType);\n\n      default:\n        return true;\n    }\n  } else {\n    return checkPaddingDirect(bytes, length, paddingType);\n  }\n}\n\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = allocate_1.byteLength(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n  return removePaddingDirect(bytes, length, paddingType);\n}\n\nfunction removePaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"right\":\n      return bytes.slice(0, length);\n\n    default:\n      return bytes.slice(-length);\n  }\n}\n\nfunction checkPaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n      return checkPaddingLeft(bytes, length);\n\n    case \"right\":\n      return checkPaddingRight(bytes, length);\n\n    case \"signed\":\n      return checkPaddingSigned(bytes, length);\n\n    case \"signedOrLeft\":\n      return checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length);\n  }\n}\n\nfunction getPaddingType(dataType, paddingMode) {\n  switch (paddingMode) {\n    case \"right\":\n      return \"right\";\n\n    case \"default\":\n    case \"permissive\":\n      return defaultPaddingType(dataType);\n\n    case \"zero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"left\" : defaultType;\n      }\n\n    case \"defaultOrZero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"signedOrLeft\" : defaultType;\n      }\n  }\n}\n\nfunction defaultPaddingType(dataType) {\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      return \"right\";\n\n    case \"int\":\n    case \"fixed\":\n      return \"signed\";\n\n    case \"function\":\n      if (dataType.visibility === \"external\") {\n        return \"right\";\n      }\n\n    //otherwise, fall through to default\n\n    default:\n      return \"left\";\n  }\n}\n\nfunction checkPaddingRight(bytes, length) {\n  let padding = bytes.slice(length); //cut off the first length bytes\n\n  return padding.every(paddingByte => paddingByte === 0);\n} //exporting this one for use in stack.ts\n\n\nfunction checkPaddingLeft(bytes, length) {\n  let padding = bytes.slice(0, -length); //cut off the last length bytes\n\n  return padding.every(paddingByte => paddingByte === 0);\n}\n\nexports.checkPaddingLeft = checkPaddingLeft;\n\nfunction checkPaddingSigned(bytes, length) {\n  let padding = bytes.slice(0, -length); //padding is all but the last length bytes\n\n  let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n\n  let signByte = value[0] & 0x80 ? 0xff : 0x00;\n  return padding.every(paddingByte => paddingByte === signByte);\n}","map":{"version":3,"mappings":"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","names":["debug","debug_1","decodeBasic","dataType","pointer","info","options","state","strictAbiMode","strict","paddingMode","bytes","rawBytes","read_1","error","errors_1","typeClass","fullType","Format","Types","userDefinedTypes","underlyingType","kind","type","allowRetry","underlyingResult","value","checkPadding","paddingType","getPaddingType","raw","Conversion","toHexString","removePadding","numeric","toBN","eqn","asBoolean","rawAsBN","asBN","toSignedBN","asAddress","Evm","Utils","toAddress","rawAsHex","contractValueInfo","decodeContract","coercedDataType","asHex","visibility","address","slice","ADDRESS_SIZE","selector","SELECTOR_SIZE","decodeExternalFunction","deployedPc","PC_SIZE","constructorPc","decodeInternalFunction","numOptions","length","numBytes","Math","ceil","log2","checkPaddingDirect","removePaddingDirect","ltn","name","toNumber","numericAsBN","asBig","shiftBigDown","toBig","places","rawAsBig","exports","addressBytes","decodeContractAndContext","contractInfo","rawAddress","codeBytes","code","context","Contexts","findContext","contexts","class","Import","contextToType","selectorBytes","contract","abiEntry","abi","undefined","deployedPcBytes","constructorPcBytes","currentContext","internalFunctionsTable","deployedProgramCounter","constructorProgramCounter","isConstructor","pc","functionEntry","isDesignatedInvalid","mutability","definedIn","functionTableEntryToType","id","makeInternalFunctionId","allocate_1","checkPaddingLeft","checkPaddingRight","checkPaddingSigned","defaultPaddingType","defaultType","padding","every","paddingByte","signByte"],"sourceRoot":"","sources":["../../../../lib/basic/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}